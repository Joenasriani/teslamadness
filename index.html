<!DOCTYPE html>
<html lang="en">
<head>
    <title>AR/VR Tetris 3D (v70 - Universal Launch)</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Required for AR/VR -->
    <meta name="xr-spatial-tracking" content="true">
    
    <!-- Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300;400;600;800&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons+Round" rel="stylesheet">

    <style>
        /* --- CORE STYLES --- */
        body, html {
            width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
            font-family: 'Montserrat', sans-serif; 
            background-color: #050505; color: white; touch-action: none; 
        }
        canvas { display: block; width: 100%; height: 100%; outline: none; }
        
        /* --- UI ELEMENTS --- */
        .glass-panel {
            background: rgba(20, 20, 20, 0.85); 
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px; pointer-events: none; 
        }

        #hud-panel {
            position: absolute; top: 20px; left: 20px;
            padding: 12px 18px; display: flex; flex-direction: column; gap: 4px;
            z-index: 100; opacity: 0; transition: opacity 0.5s ease;
        }
        .hud-row { display: flex; justify-content: space-between; font-size: 0.9rem; font-weight: 700; }
        .hud-label { color: #888; margin-right: 12px; font-weight: 500; }
        #score-val { color: #FFDC00; }
        #level-val { color: #00FFFF; }

        /* Recording Indicator */
        #recording-panel {
            position: absolute; top: 100px; left: 20px;
            display: none; align-items: center; gap: 8px;
            padding: 6px 12px; border-radius: 20px;
            background: rgba(255, 0, 0, 0.15); border: 1px solid rgba(255, 0, 0, 0.4);
            z-index: 100;
        }
        #recording-dot {
            width: 8px; height: 8px; background-color: #FF4136;
            border-radius: 50%; animation: blink-red 1s infinite;
        }
        #rec-time { font-size: 0.8rem; font-weight: 600; color: #FF4136; font-variant-numeric: tabular-nums; }
        @keyframes blink-red { 50% { opacity: 0.3; } }

        /* Controls */
        .control-btn {
            position: absolute; width: 48px; height: 48px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            cursor: pointer; z-index: 102; pointer-events: auto;
            background: rgba(40, 40, 40, 0.6); backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 255, 255, 0.2); color: white;
            transition: transform 0.1s;
        }
        .control-btn:active { transform: scale(0.92); }
        #music-toggle { top: 20px; right: 20px; }
        #record-button { top: 80px; right: 20px; }
        #record-button.recording { background: rgba(255, 0, 0, 0.8); animation: pulse-rec 2s infinite; }
        @keyframes pulse-rec { 0% { box-shadow: 0 0 0 0 rgba(255,0,0,0.6); } 70% { box-shadow: 0 0 0 10px transparent; } }

        /* Game Messages */
        #message-box {
            position: absolute; top: 15%; left: 50%; transform: translateX(-50%);
            z-index: 100; padding: 12px 24px; text-align: center;
            display: none; align-items: center; gap: 10px; font-weight: 600;
            white-space: nowrap; pointer-events: none;
        }

        /* Launch Button */
        #custom-ar-button {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%);
            padding: 16px 40px; border-radius: 50px;
            background: linear-gradient(135deg, #8a2be2, #4169e1);
            color: white; font-family: 'Montserrat', sans-serif; font-size: 1.1rem; font-weight: 800;
            border: none; box-shadow: 0 8px 20px rgba(138, 43, 226, 0.4);
            cursor: pointer; z-index: 101; letter-spacing: 1px; text-transform: uppercase;
            animation: btn-pulse 2s infinite;
            display: block; /* Always block, controlled by opacity */
            transition: opacity 0.3s, transform 0.1s;
        }
        #custom-ar-button.disabled {
            background: #444; color: #888; box-shadow: none; animation: none; cursor: not-allowed;
        }
        @keyframes btn-pulse { 0% { box-shadow: 0 0 0 0 rgba(138,43,226,0.7); } 70% { box-shadow: 0 0 0 15px transparent; } }

        /* Game Over */
        #game-over-card {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 85%; max-width: 320px; padding: 30px;
            display: none; flex-direction: column; align-items: center; gap: 20px;
            z-index: 105; text-align: center; pointer-events: auto;
        }
        .go-title { font-size: 2.2rem; font-weight: 900; color: #FF4136; margin: 0; }
        .stat-row { display: flex; justify-content: space-between; width: 100%; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px; }
        #replay-button {
            width: 100%; padding: 14px; border-radius: 30px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            border: none; color: white; font-weight: 700; font-size: 1rem;
            cursor: pointer; margin-top: 10px;
        }

        /* Intro */
        #intro-screen {
            position: absolute; inset: 0; background: black;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 200; transition: opacity 0.8s;
        }
        .intro-t1 { font-size: 3.5rem; font-weight: 900; color: #FF00FF; line-height: 0.9; text-align: center; }
        .intro-t2 { font-size: 1.2rem; font-weight: 300; color: #00FFFF; letter-spacing: 5px; margin-top: 10px; }
        #intro-credits {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: #666; font-size: 0.75rem; pointer-events: none; line-height: 1.6;
        }
    </style>
</head>
<body>

    <!-- UI LAYER -->
    <div id="intro-screen">
        <div class="intro-t1">TETRIS<br>XR</div>
        <div class="intro-t2">AR/VR EDITION</div>
    </div>

    <div id="hud-panel" class="glass-panel">
        <div class="hud-row"><span class="hud-label">SCORE</span><span id="score-val">0</span></div>
        <div class="hud-row"><span class="hud-label">LEVEL</span><span id="level-val">1</span></div>
    </div>

    <div id="recording-panel">
        <div id="recording-dot"></div>
        <div id="rec-time">00:00</div>
    </div>

    <div id="message-box" class="glass-panel"><span id="message-text">Scan floor</span></div>

    <div id="game-over-card" class="glass-panel">
        <div class="go-title">GAME OVER</div>
        <div class="stat-row"><span>Score</span><span id="go-score">0</span></div>
        <div class="stat-row"><span>Level</span><span id="go-level">1</span></div>
        <button id="replay-button">PLAY AGAIN</button>
    </div>

    <!-- BUTTONS -->
    <button id="music-toggle" class="control-btn"><span class="material-icons-round" id="icon-music">volume_up</span></button>
    <button id="record-button" class="control-btn"><span class="material-icons-round" id="icon-rec">fiber_manual_record</span></button>
    
    <button id="custom-ar-button" class="disabled">CHECKING...</button>
    
    <div id="intro-credits">
        Developed by JN with Vibe Coding AI<br>
        Controls: Arrows (PC) / Touch (Mobile) / Hands (VR)<br>
        v70 - Universal Launch
    </div>

    <!-- THREE.JS IMPORTS -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';

        // --- GLOBAL VARIABLES ---
        let camera, scene, renderer;
        let controller1, controller2, controllerGrip1, controllerGrip2;
        let raycaster;
        let hitTestSource = null;
        let xrSession = null;
        let currentSessionMode = null;
        
        // Game Objects
        let placementGrid, gameBoard, currentPiece;
        let ghostPiece = null;
        
        // Logic
        let gameLoopInterval;
        let gameState = 0; // 0:Init, 1:Scan, 2:Place, 3:Play, 4:Over
        let score = 0, level = 1, linesClearedTotal = 0;
        let currentDropSpeed = 1000;
        
        // Interaction (Physics Grab)
        let isGrabbing = false;
        let grabbedObject = null;
        let grabController = null;
        
        // Constants
        const BOARD_W = 10, BOARD_H = 20, BLOCK_SIZE = 0.08; 
        const COLORS = [0x00F0F0, 0xF0F000, 0xA000F0, 0x00F000, 0xF00000, 0x0000F0, 0xF0A000];
        const SHAPES = [
            [[[1,1,1,1]], [[1],[1],[1],[1]]], // I
            [[[1,1],[1,1]]], // O
            [[[0,1,0],[1,1,1]], [[1,0],[1,1],[1,0]], [[1,1,1],[0,1,0]], [[0,1],[1,1],[0,1]]], // T
            [[[0,1,1],[1,1,0]], [[1,0],[1,1],[0,1]]], // S
            [[[1,1,0],[0,1,1]], [[0,1],[1,1],[1,0]]], // Z
            [[[1,0,0],[1,1,1]], [[1,1],[1,0],[1,0]], [[1,1,1],[0,0,1]], [[0,1],[0,1],[1,1]]], // J
            [[[0,0,1],[1,1,1]], [[1,0],[1,0],[1,1]], [[1,1,1],[1,0,0]], [[1,1],[0,1],[0,1]]]  // L
        ];
        
        let grid = Array(BOARD_H).fill().map(()=>Array(BOARD_W).fill(0));
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        
        // UI DOM
        const ui = {
            arBtn: document.getElementById('custom-ar-button'),
            hud: document.getElementById('hud-panel'),
            score: document.getElementById('score-val'),
            level: document.getElementById('level-val'),
            msgBox: document.getElementById('message-box'),
            msgText: document.getElementById('message-text'),
            gameOver: document.getElementById('game-over-card'),
            intro: document.getElementById('intro-screen'),
            recBtn: document.getElementById('record-button'),
            recPanel: document.getElementById('recording-panel'),
            recTime: document.getElementById('rec-time')
        };

        let mediaRecorder, recordedChunks = [], recTimerInt;
        let isRecording = false;

        init();
        setupAudio();
        // Check both AR and VR support
        checkXRSupport();

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            
            const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 2); 
            hemi.position.set(0, 2, 0);
            scene.add(hemi);
            const dir = new THREE.DirectionalLight(0xffffff, 2);
            dir.position.set(0, 5, 2);
            scene.add(dir);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // --- CONTROLLERS ---
            raycaster = new THREE.Raycaster();
            
            controller1 = renderer.xr.getController(0);
            controller1.addEventListener('selectstart', onSelectStart);
            controller1.addEventListener('selectend', onSelectEnd);
            scene.add(controller1);
            
            controller2 = renderer.xr.getController(1);
            controller2.addEventListener('selectstart', onSelectStart);
            controller2.addEventListener('selectend', onSelectEnd);
            scene.add(controller2);

            // Controller Rays
            const lineGeo = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,-5)]);
            const lineMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.5 });
            controller1.add(new THREE.Line(lineGeo, lineMat));
            controller2.add(new THREE.Line(lineGeo.clone(), lineMat));

            // Visual Hands
            const controllerModelFactory = new XRControllerModelFactory();
            controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);
            controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            // Game Objects
            const gridGeo = new THREE.PlaneGeometry(BOARD_W * BLOCK_SIZE, BOARD_W * BLOCK_SIZE);
            const gridMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, wireframe: true, transparent: true, opacity: 0.5 });
            placementGrid = new THREE.Mesh(gridGeo, gridMat);
            placementGrid.rotation.x = -Math.PI/2;
            placementGrid.visible = false;
            scene.add(placementGrid);

            gameBoard = new THREE.Group();
            scene.add(gameBoard); 

            // Ghost Piece
            const ghostGeo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const ghostMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, wireframe: true });
            ghostPiece = new THREE.Group();
            ghostPiece.add(new THREE.Mesh(ghostGeo, ghostMat));
            ghostPiece.visible = false;
            gameBoard.add(ghostPiece);

            // Listeners
            window.addEventListener('keydown', handleKey);
            window.addEventListener('resize', onWindowResize);
            setupTouch();
            
            document.getElementById('replay-button').addEventListener('click', resetGame);
            ui.recBtn.addEventListener('click', toggleRecord);

            renderer.setAnimationLoop(render);
        }

        // --- UNIVERSAL LAUNCH LOGIC ---

        function checkXRSupport() {
            if ('xr' in navigator) {
                // Check AR (Preferred for Phones)
                navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                    if (supported) {
                        enableButton('immersive-ar', 'ENTER AR');
                    } else {
                        // Check VR (Preferred for Headsets)
                        navigator.xr.isSessionSupported('immersive-vr').then((vrSupported) => {
                            if (vrSupported) {
                                enableButton('immersive-vr', 'ENTER VR');
                            } else {
                                disableButton("DEVICE NOT SUPPORTED");
                            }
                        });
                    }
                }).catch(e => {
                     // Often happens on non-secure contexts (http vs https)
                     console.error(e);
                     disableButton("WEBXR ERROR (HTTPS?)");
                });
            } else {
                disableButton("WEBXR NOT FOUND");
            }
        }

        function enableButton(mode, text) {
            ui.arBtn.classList.remove('disabled');
            ui.arBtn.innerText = text;
            currentSessionMode = mode;
            ui.arBtn.addEventListener('click', onButtonClick);
        }

        function disableButton(text) {
             ui.arBtn.classList.add('disabled');
             ui.arBtn.innerText = text;
             // Allow click to explain why
             ui.arBtn.addEventListener('click', () => {
                 alert("Your browser/device does not support WebXR Immersive Mode. \n\nEnsure you are using:\n- Chrome on Android (for AR)\n- Meta Quest Browser (for VR)\n- HTTPS Connection");
             });
        }

        async function onButtonClick() {
            if(!currentSessionMode) return;
            unlockAudio();
            
            if (xrSession) {
                xrSession.end();
                return;
            }

            try {
                // VR needs different reference space types usually, but 'local-floor' works for both often
                const sessionOptions = {
                    requiredFeatures: ['hit-test'], // Required for AR
                    optionalFeatures: ['dom-overlay', 'local-floor', 'bounded-floor', 'hand-tracking'],
                    domOverlay: { root: document.body }
                };

                // Remove hit-test requirement for VR mode (some VR headsets don't support AR hit-test)
                if (currentSessionMode === 'immersive-vr') {
                    sessionOptions.requiredFeatures = ['local-floor'];
                    delete sessionOptions.optionalFeatures; // simplify for VR
                }

                const session = await navigator.xr.requestSession(currentSessionMode, sessionOptions);
                session.addEventListener('end', onSessionEnded);
                
                await renderer.xr.setSession(session);
                xrSession = session;
                
                ui.arBtn.innerText = "EXIT IMMERSIVE";
                
                // If VR, we skip scanning and go straight to placement/play
                if (currentSessionMode === 'immersive-vr') {
                    // Place board in front of user
                    gameBoard.position.set(0, 0, -1); // 1 meter in front
                    placementGrid.visible = false;
                    startGame(); 
                } else {
                    gameState = 1; // AR Scanning
                    ui.msgText.innerText = "Scan floor...";
                }
                
            } catch (e) {
                alert("Launch Failed: " + e.message);
            }
        }

        function onSessionEnded() {
            xrSession = null;
            ui.arBtn.innerText = "ENTER IMMERSIVE";
            window.location.reload(); 
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- INTERACTION LOGIC ---

        function onSelectStart(event) {
            if (gameState === 2) { 
                startGame(); 
                return; 
            }
            if (gameState === 3 && currentPiece) {
                const controller = event.target;
                const piecePos = new THREE.Vector3();
                currentPiece.getWorldPosition(piecePos);
                // 35cm radius
                if (controller.position.distanceTo(piecePos) < 0.35) {
                    isGrabbing = true;
                    grabController = controller;
                    grabbedObject = currentPiece;
                    clearInterval(gameLoopInterval);
                    controller.attach(grabbedObject); 
                    playSynthSound(440, 'triangle', 0.1);
                    triggerHaptic(event.target, 0.5, 20);
                }
            }
        }

        function onSelectEnd(event) {
            if (isGrabbing && grabController === event.target) {
                gameBoard.attach(grabbedObject);
                const lx = grabbedObject.position.x;
                const ly = grabbedObject.position.y;
                let gx = Math.round(lx / BLOCK_SIZE + (BOARD_W / 2) - 0.5);
                let gy = Math.round((BOARD_H / 2 - 0.5) - (ly / BLOCK_SIZE));

                if (gx < 0) gx = 0; if (gx >= BOARD_W) gx = BOARD_W - 1;
                
                const ud = currentPiece.userData;
                const oldX = ud.gridPos.x;
                const oldY = ud.gridPos.y;
                
                if (isValidMove(currentPiece, { pos: {x: gx, y: gy} })) {
                    ud.gridPos.x = gx;
                    ud.gridPos.y = gy;
                    playSynthSound(880, 'sine', 0.1); 
                } else {
                    ud.gridPos.x = oldX;
                    ud.gridPos.y = oldY;
                    playSynthSound(150, 'sawtooth', 0.2); 
                    triggerHaptic(event.target, 1.0, 50);
                }

                updatePieceVisuals();
                ghostPiece.visible = false;
                isGrabbing = false;
                grabbedObject = null;
                grabController = null;
                gameLoopInterval = setInterval(gameTick, currentDropSpeed);
            }
        }

        function triggerHaptic(controller, strength, duration) {
            if (controller.gamepad && controller.gamepad.hapticActuators && controller.gamepad.hapticActuators.length > 0) {
                controller.gamepad.hapticActuators[0].pulse(strength, duration);
            }
        }

        // --- GAME LOOP ---

        function render(timestamp, frame) {
            if (gameState === 1 && frame) handleHitTest(frame);

            if (isGrabbing && grabbedObject) {
                const worldPos = new THREE.Vector3();
                grabbedObject.getWorldPosition(worldPos);
                gameBoard.worldToLocal(worldPos);
                const gx = Math.round(worldPos.x / BLOCK_SIZE + (BOARD_W / 2) - 0.5);
                const gy = Math.round((BOARD_H / 2 - 0.5) - (worldPos.y / BLOCK_SIZE));
                if (gx >= 0 && gx < BOARD_W && gy < BOARD_H) {
                    ghostPiece.visible = true;
                    ghostPiece.position.set(
                        (gx - BOARD_W/2 + 0.5) * BLOCK_SIZE,
                        (BOARD_H/2 - 0.5 - gy) * BLOCK_SIZE,
                        0
                    );
                    const isValid = isValidMove(grabbedObject, { pos: {x: gx, y: gy} });
                    ghostPiece.children[0].material.color.setHex(isValid ? 0x00FF00 : 0xFF0000);
                } else {
                    ghostPiece.visible = false;
                }
            }
            renderer.render(scene, camera);
        }

        function handleHitTest(frame) {
            if(currentSessionMode === 'immersive-vr') return; // No hit test in VR

            const session = renderer.xr.getSession();
            if (!session) return;
            if (!hitTestSource) {
                session.requestReferenceSpace('viewer').then(refSpace => {
                    session.requestHitTestSource({ space: refSpace }).then(source => hitTestSource = source);
                });
                return;
            }
            const results = frame.getHitTestResults(hitTestSource);
            if (results.length) {
                const hit = results[0];
                const pose = hit.getPose(renderer.xr.getReferenceSpace());
                placementGrid.visible = true;
                placementGrid.matrix.fromArray(pose.transform.matrix);
                if (gameState === 1) {
                    ui.msgText.innerText = "Tap trigger to Place";
                    gameState = 2; 
                }
            } else {
                placementGrid.visible = false;
                if (gameState === 2) {
                    gameState = 1; 
                    ui.msgText.innerText = "Scan floor...";
                }
            }
        }

        function startGame() {
            // For AR, lock grid. For VR, it's already placed.
            if (currentSessionMode === 'immersive-ar') {
                const pos = new THREE.Vector3();
                const quat = new THREE.Quaternion();
                const scale = new THREE.Vector3();
                placementGrid.matrix.decompose(pos, quat, scale);
                gameBoard.position.copy(pos);
                gameBoard.quaternion.copy(quat);
                gameBoard.translateY( (BOARD_H/2) * BLOCK_SIZE ); 
                placementGrid.visible = false;
            }

            ui.hud.style.opacity = 1;
            ui.msgBox.style.display = 'none';
            ui.intro.style.opacity = 0;
            setTimeout(()=>ui.intro.style.display='none', 800);

            gameState = 3; 
            score = 0; level = 1;
            updateScore(0);
            spawnPiece();
            gameLoopInterval = setInterval(gameTick, currentDropSpeed);
        }

        function gameTick() {
            if (!currentPiece || isGrabbing) return;
            if (isValidMove(currentPiece, { y: 1 })) {
                currentPiece.userData.gridPos.y++;
                updatePieceVisuals();
            } else {
                lockPiece();
            }
        }

        function spawnPiece() {
            const typeId = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[typeId][0]; 
            const color = COLORS[typeId];
            const group = new THREE.Group();
            group.userData = { shape: shape, typeId: typeId, rotId: 0, gridPos: { x: Math.floor(BOARD_W/2)-1, y: 0 } };
            const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const mat = new THREE.MeshStandardMaterial({ color: color, roughness: 0.2, metalness: 0.1, transparent: true, opacity: 0.9 });
            const edgeGeo = new THREE.EdgesGeometry(geo);
            const edgeMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 });
            shape.forEach((row, y) => {
                row.forEach((val, x) => {
                    if (val) {
                        const m = new THREE.Mesh(geo, mat);
                        m.add(new THREE.LineSegments(edgeGeo, edgeMat));
                        m.position.set(x * BLOCK_SIZE, -y * BLOCK_SIZE, 0);
                        group.add(m);
                    }
                });
            });
            gameBoard.add(group);
            currentPiece = group;
            updatePieceVisuals();
            if (!isValidMove(currentPiece, {})) gameOver();
        }

        function updatePieceVisuals() {
            if (!currentPiece) return;
            const ud = currentPiece.userData;
            const x = (ud.gridPos.x - BOARD_W/2 + 0.5) * BLOCK_SIZE;
            const y = (BOARD_H/2 - 0.5 - ud.gridPos.y) * BLOCK_SIZE;
            currentPiece.position.set(x, y, 0);
        }

        function lockPiece() {
            if(!currentPiece) return;
            const ud = currentPiece.userData;
            const shape = ud.shape;
            const pieceX = ud.gridPos.x;
            const pieceY = ud.gridPos.y;
            shape.forEach((row, ry) => {
                row.forEach((val, rx) => {
                    if (val) {
                        const gx = pieceX + rx;
                        const gy = pieceY + ry;
                        if (gy >= 0 && gy < BOARD_H && gx >= 0 && gx < BOARD_W) {
                            grid[gy][gx] = 1; 
                            const oldBlock = currentPiece.children.find(b => Math.abs(b.position.x - rx*BLOCK_SIZE) < 0.001 && Math.abs(b.position.y - (-ry*BLOCK_SIZE)) < 0.001);
                            if (oldBlock) {
                                const newBlock = oldBlock.clone();
                                newBlock.position.set((gx - BOARD_W/2 + 0.5) * BLOCK_SIZE, (BOARD_H/2 - 0.5 - gy) * BLOCK_SIZE, 0);
                                gameBoard.add(newBlock);
                            }
                        }
                    }
                });
            });
            gameBoard.remove(currentPiece);
            currentPiece = null;
            playSynthSound(200, 'square', 0.1); 
            checkLines();
            spawnPiece();
        }

        function checkLines() {
            let cleared = 0;
            for (let y = BOARD_H-1; y >= 0; y--) {
                if (grid[y].every(v => v !== 0)) {
                    cleared++;
                    grid.splice(y, 1);
                    grid.unshift(Array(BOARD_W).fill(0));
                    y++; 
                }
            }
            if (cleared > 0) {
                for(let i=gameBoard.children.length-1; i>=0; i--){
                    if(gameBoard.children[i] !== currentPiece && gameBoard.children[i] !== ghostPiece) {
                        gameBoard.remove(gameBoard.children[i]);
                    }
                }
                const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                const edgeGeo = new THREE.EdgesGeometry(geo);
                grid.forEach((row, gy) => {
                    row.forEach((val, gx) => {
                        if (val) {
                            const mat = new THREE.MeshStandardMaterial({ color: 0x888888 }); 
                            const m = new THREE.Mesh(geo, mat);
                            m.add(new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:0})));
                            m.position.set((gx - BOARD_W/2 + 0.5) * BLOCK_SIZE, (BOARD_H/2 - 0.5 - gy) * BLOCK_SIZE, 0);
                            gameBoard.add(m);
                        }
                    });
                });
                playSynthSound(600 + (cleared*100), 'sine', 0.3);
                updateScore(cleared);
            }
        }

        function isValidMove(piece, delta) {
            const ud = piece.userData;
            const shape = delta.shape || ud.shape;
            const px = (delta.pos ? delta.pos.x : ud.gridPos.x) + (delta.x || 0);
            const py = (delta.pos ? delta.pos.y : ud.gridPos.y) + (delta.y || 0);
            for(let y=0; y<shape.length; y++){
                for(let x=0; x<shape[y].length; x++){
                    if(shape[y][x]){
                        const gx = px + x;
                        const gy = py + y;
                        if (gx < 0 || gx >= BOARD_W || gy >= BOARD_H) return false;
                        if (gy >= 0 && grid[gy][gx]) return false;
                    }
                }
            }
            return true;
        }

        function gameOver() {
            clearInterval(gameLoopInterval);
            gameState = 4;
            document.getElementById('go-score').innerText = score;
            document.getElementById('go-level').innerText = level;
            ui.gameOver.style.display = 'flex';
        }

        function resetGame() {
            grid = Array(BOARD_H).fill().map(()=>Array(BOARD_W).fill(0));
            while(gameBoard.children.length) gameBoard.remove(gameBoard.children[0]);
            gameBoard.add(ghostPiece);
            ghostPiece.visible = false;
            ui.gameOver.style.display = 'none';
            startGame();
        }

        function updateScore(lines) {
            score += lines * 100 * level;
            linesClearedTotal += lines;
            level = Math.floor(linesClearedTotal / 5) + 1;
            ui.score.innerText = score;
            ui.level.innerText = level;
            currentDropSpeed = Math.max(100, 1000 - (level*50));
        }

        function handleKey(e) {
            if(gameState !== 3 || isGrabbing) return;
            if(e.key === 'ArrowLeft') move(-1);
            if(e.key === 'ArrowRight') move(1);
            if(e.key === 'ArrowDown') gameTick();
            if(e.code === 'Space') rotatePiece();
        }

        function rotatePiece() {
            if(!currentPiece) return;
            const ud = currentPiece.userData;
            const curShape = ud.shape;
            const N = curShape.length; const M = curShape[0].length;
            const newShape = Array(M).fill().map(()=>Array(N).fill(0));
            for(let y=0; y<N; y++) for(let x=0; x<M; x++) newShape[x][N-1-y] = curShape[y][x];
            if(isValidMove(currentPiece, {shape: newShape})){
                ud.shape = newShape;
                while(currentPiece.children.length) currentPiece.remove(currentPiece.children[0]);
                const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
                const mat = new THREE.MeshStandardMaterial({ color: COLORS[ud.typeId], roughness:0.2 });
                const edgeGeo = new THREE.EdgesGeometry(geo);
                newShape.forEach((row, y) => { row.forEach((val, x) => { if(val){ const m = new THREE.Mesh(geo, mat); m.add(new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({color:0}))); m.position.set(x*BLOCK_SIZE, -y*BLOCK_SIZE, 0); currentPiece.add(m); }});});
            }
        }

        function move(dir) { if(isValidMove(currentPiece, {x: dir})){ currentPiece.userData.gridPos.x += dir; updatePieceVisuals(); }}

        function setupTouch() {
            let tx=0, ty=0;
            window.addEventListener('touchstart', e => { tx=e.touches[0].clientX; ty=e.touches[0].clientY; });
            window.addEventListener('touchend', e => {
                if(gameState !== 3) return;
                const dx = e.changedTouches[0].clientX - tx;
                const dy = e.changedTouches[0].clientY - ty;
                if(Math.abs(dx) > Math.abs(dy)) { if(Math.abs(dx) > 30) move(dx>0?1:-1); } 
                else { if(dy > 30) gameTick(); else if(dy < -30) rotatePiece(); }
            });
        }

        function setupAudio() {}
        function unlockAudio() { if(audioCtx.state === 'suspended') audioCtx.resume(); }
        function playSynthSound(freq, type, duration) {
            if(audioCtx.state === 'suspended') return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        }

        function toggleRecord() {
            if(isRecording) {
                mediaRecorder.stop();
                ui.recBtn.classList.remove('recording');
                ui.recPanel.style.display = 'none';
                clearInterval(recTimerInt);
                isRecording = false;
            } else {
                const stream = renderer.domElement.captureStream(30);
                mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
                recordedChunks = [];
                mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
                mediaRecorder.onstop = saveVideo;
                mediaRecorder.start();
                isRecording = true;
                ui.recBtn.classList.add('recording');
                ui.recPanel.style.display = 'flex';
                let s = 0;
                recTimerInt = setInterval(() => { s++; const min = Math.floor(s/60).toString().padStart(2,'0'); const sec = (s%60).toString().padStart(2,'0'); ui.recTime.innerText = `${min}:${sec}`; }, 1000);
            }
        }
        function saveVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a'); a.href = url; a.download = 'immersive-tetris.webm'; a.click();
        }
    </script>
</body>
</html>


