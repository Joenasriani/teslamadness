<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tesla Madness 1998 - Drift Master Edition</title>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* LEFT HEADER UI */
        #ui-layer {
            position: absolute;
            top: max(20px, env(safe-area-inset-top)); 
            left: max(20px, env(safe-area-inset-left));
            color: #ffcc00;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            z-index: 10;
            width: auto;
            max-width: 50%;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        h1 { 
            margin: 0; 
            font-size: clamp(14px, 4vw, 24px); 
            letter-spacing: 1px; 
            text-transform: uppercase; 
            font-weight: bold; 
            white-space: nowrap; 
            line-height: 1.2;
        }
        p { margin: 5px 0; font-size: clamp(9px, 2.5vw, 14px); color: #fff; }
        .accent { color: #00ff00; }
        .blink { animation: blinker 1.5s linear infinite; color: #ff00ff; }
        @keyframes blinker { 50% { opacity: 0; } }

        /* BATTERY BAR */
        .battery-container {
            margin-top: 25px; 
            width: 100%;
            max-width: 200px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #fff;
            position: relative;
        }
        #battery-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.2s;
        }
        #battery-text {
            position: absolute;
            top: -18px; 
            right: 0;
            font-size: clamp(9px, 2.5vw, 12px);
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        
        /* RIGHT HEADER UI */
        .hud-stats {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            text-align: right;
            color: #fff;
            z-index: 10;
            pointer-events: none;
            font-size: clamp(12px, 3.5vw, 16px);
            max-width: 40%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        /* DRIFT INDICATOR */
        #drift-indicator {
            color: #ff6600;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
            font-size: clamp(10px, 3vw, 14px);
            opacity: 0;
            transition: opacity 0.3s;
        }

        #drift-indicator.active {
            opacity: 1;
            animation: pulse-drift 0.5s infinite alternate;
        }

        @keyframes pulse-drift {
            0% { transform: scale(1); color: #ff6600; }
            100% { transform: scale(1.1); color: #ffaa00; }
        }

        /* HUD BUTTONS */
        .hud-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffcc00;
            padding: 5px 8px;
            color: #ffcc00;
            font-weight: bold;
            text-transform: uppercase;
            font-size: clamp(9px, 2.5vw, 12px);
            pointer-events: auto; 
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
            text-shadow: 1px 1px 0 #000;
            transition: background 0.1s, opacity 0.2s;
        }
        
        .hud-btn:active { background: rgba(255, 204, 0, 0.3); }

        .hud-btn.off {
            border-color: #555;
            color: #888;
            opacity: 0.7;
        }

        /* LOADING SCREEN */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(280px, 60vw, 500px);
            background: black;
            padding: 20px;
            border: 2px solid #ffcc00;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.2);
        }
        .loading-title { color: white; font-size: clamp(16px, 4vw, 20px); margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .progress-track { width: 100%; height: 20px; background: #222; border: 1px solid #555; margin-bottom: 10px; position: relative; }
        #progress-bar { width: 0%; height: 100%; background: #ffcc00; transition: width 0.2s; }
        #loading-text { color: #aaa; font-size: 12px; }
        .error-msg { color: #ff3333 !important; }

        /* --- MOBILE CONTROLS --- */
        .touch-controls {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 0;
            width: 100%;
            height: auto;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            box-sizing: border-box;
            align-items: flex-end;
        }

        /* SHARED ZONE STYLES */
        .control-zone {
            width: 45%; height: 250px;
            pointer-events: auto;
            touch-action: none;
            position: relative;
        }

        /* TEXT HINTS */
        .zone-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255,255,255,0.3);
            font-size: 12px;
            pointer-events: none;
            font-weight: bold;
            text-transform: uppercase;
        }
        .hint-left { left: 0; }
        .hint-right { right: 0; text-align: right; }

        /* DYNAMIC VISUAL ELEMENTS */
        .touch-feedback-base {
            position: absolute;
            width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 204, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }
        
        .touch-feedback-knob {
            position: absolute;
            width: 50px; height: 50px;
            background: rgba(255, 204, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: 50%; top: 50%;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.6);
        }

        /* HANDBRAKE BUTTON VISUAL */
        #brake-visual .touch-feedback-knob {
            width: 90px; height: 90px;
            background: rgba(255, 100, 50, 0.8);
            border: 2px solid #ff6600;
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 12px;
        }
        
        #brake-visual .touch-feedback-knob::after {
            content: "HANDBRAKE";
        }

        /* TIRE SMOKE PARTICLES */
        .tire-smoke {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(150, 150, 150, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1;
        }

    </style>
</head>
<body>

    <div id="loading">
        <div class="loading-title">CHARGING CYBERTRUCK...</div>
        <div class="progress-track">
            <div id="progress-bar"></div>
        </div>
        <div id="loading-text">LOADING ASSETS...</div>
    </div>

    <!-- LEFT HEADER -->
    <div id="ui-layer">
        <h1>TESLA CYBERTRUCK DRIFT</h1>
        <div class="battery-container">
            <div id="battery-bar"></div>
            <div id="battery-text">BATTERY: 100%</div>
        </div>
        <p>COLLECT <span style="color:gold">GOLD RINGS</span></p>
        <p>HANDBRAKE + TURN = <span class="accent">SLIDE</span></p>
    </div>

    <!-- RIGHT HEADER -->
    <div class="hud-stats">
        <div id="speed">0 KM/H</div>
        <div id="drift-indicator">ðŸ”¥ SLIDING ðŸ”¥</div>
        <div id="fps">60 FPS</div>
        
        <!-- BUTTONS -->
        <div id="camera-indicator" class="hud-btn">CAM: FAR CHASE</div>
        <div id="music-indicator" class="hud-btn">MUSIC: ON</div>
        <div id="sfx-indicator" class="hud-btn">SFX: ON</div>
    </div>

    <!-- CONTROLS -->
    <div class="touch-controls">
        <!-- LEFT: JOYSTICK -->
        <div id="joystick-zone" class="control-zone">
            <div class="zone-hint hint-left">MOVE & STEER</div>
            <div class="touch-feedback-base" id="joy-visual">
                <div class="touch-feedback-knob" id="joy-knob"></div>
            </div>
        </div>
        
        <!-- RIGHT: HANDBRAKE -->
        <div id="brake-zone" class="control-zone">
            <div class="zone-hint hint-right">HANDBRAKE DRIFT</div>
            <div class="touch-feedback-base" id="brake-visual">
                <div class="touch-feedback-knob"></div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer;
        let bikeGroup, terrainMesh;
        let speed = 0;
        let velocity = new THREE.Vector3();
        let lateralVelocity = new THREE.Vector3(); // For handbrake sliding
        let verticalVelocity = 0; 
        let particles = [];
        let rings = []; 
        let frameCount = 0;
        let lastTime = 0;
        let isAirborne = false;
        let assetsLoaded = 0;
        let assetsTotal = 2; 
        let obstacles = [];
        
        let progressCyber = 0;
        let progressTree = 0;

        // GAMEPLAY STATS
        let battery = 100;
        const BATTERY_DRAIN = 0.05; 
        const RING_CHARGE = 20;

        // ENHANCED PHYSICS CONSTANTS
        const MAX_SPEED = 1.6; // Higher max speed for more excitement
        const ACCEL = 0.03; // Faster acceleration
        const FRICTION = 0.988; // Very smooth deceleration when coasting
        const TURN_SPEED = 0.05; // Enhanced turning
        const GRAVITY = 0.04; 
        const MAP_LIMIT = 195; 
        
        // HANDBRAKE DRIFT PHYSICS CONSTANTS
        const HANDBRAKE_SLIDE_FORCE = 0.25; // Strong lateral slide force
        const LATERAL_FRICTION = 0.92; // How lateral momentum decays
        const HANDBRAKE_FORWARD_RETENTION = 0.95; // Keep most forward speed during handbrake
        const MIN_DRIFT_SPEED = 0.4; // Minimum speed needed for effective drift
        const SLIDE_AMPLIFICATION = 1.8; // Amplify slide effect at higher speeds
        
        let isDriftActive = false;
        let driftIntensity = 0.0;
        let handbrakeHeld = false;
        
        const keys = { w: false, a: false, s: false, d: false, space: false, brake: false };
        
        let activeCameraMode = 0; 
        let analogSteering = 0;
        let analogThrottle = 0; 

        // --- ENHANCED CONTROLS LOGIC ---
        const controls = {
            init: function() {
                // JOYSTICK (LEFT)
                const joyZone = document.getElementById('joystick-zone');
                const joyVisual = document.getElementById('joy-visual');
                const joyKnob = document.getElementById('joy-knob');
                
                let joyActive = false;
                let joyOrigin = {x:0, y:0};
                const maxDist = 50;

                joyZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joyActive = true;
                    const rect = joyZone.getBoundingClientRect();
                    joyOrigin.x = touch.clientX - rect.left;
                    joyOrigin.y = touch.clientY - rect.top;
                    
                    joyVisual.style.display = 'block';
                    joyVisual.style.left = joyOrigin.x + 'px';
                    joyVisual.style.top = joyOrigin.y + 'px';
                    joyKnob.style.transform = `translate(-50%, -50%)`;
                    sfx.init(); sfx.playMusic();
                }, { passive: false });

                joyZone.addEventListener('touchmove', (e) => {
                    if (!joyActive) return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    const rect = joyZone.getBoundingClientRect();
                    
                    let dx = (touch.clientX - rect.left) - joyOrigin.x;
                    let dy = (touch.clientY - rect.top) - joyOrigin.y;
                    
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) {
                        const angle = Math.atan2(dy, dx);
                        dx = Math.cos(angle) * maxDist;
                        dy = Math.sin(angle) * maxDist;
                    }

                    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    analogSteering = -(dx / maxDist);
                    analogThrottle = -(dy / maxDist);
                }, { passive: false });

                const endJoy = () => {
                    joyActive = false;
                    joyVisual.style.display = 'none';
                    analogSteering = 0;
                    analogThrottle = 0;
                };
                joyZone.addEventListener('touchend', endJoy);
                joyZone.addEventListener('touchcancel', endJoy);

                // HANDBRAKE (RIGHT)
                const brakeZone = document.getElementById('brake-zone');
                const brakeVisual = document.getElementById('brake-visual');

                brakeZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    keys.brake = true;
                    handbrakeHeld = true;
                    sfx.init(); sfx.playMusic();
                    if(window.navigator.vibrate) window.navigator.vibrate([20, 10, 20]); // Stronger haptic for handbrake

                    const rect = brakeZone.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    brakeVisual.style.display = 'block';
                    brakeVisual.style.left = x + 'px';
                    brakeVisual.style.top = y + 'px';
                }, { passive: false });

                const endBrake = (e) => {
                    e.preventDefault();
                    keys.brake = false;
                    handbrakeHeld = false;
                    brakeVisual.style.display = 'none';
                };
                brakeZone.addEventListener('touchend', endBrake);
                brakeZone.addEventListener('touchcancel', endBrake);
            }
        };

        // ENHANCED AUDIO SYSTEM
        const sfx = {
            ctx: null, 
            // Engine sounds
            engineOsc: null, engineOsc2: null, engineGain: null, engineFilter: null,
            // Tire/drift sounds
            skidOsc: null, skidGain: null, skidFilter: null,
            // Wind sound
            windOsc: null, windGain: null, windFilter: null,
            // Noise buffer for various effects
            noiseBuffer: null, 
            // Music
            bgm: null, 
            // States
            isMusicOn: true, isSfxOn: true,
            // Audio smoothing
            smoothSpeed: 0, smoothDrift: 0,
            
            init: function() {
                if (this.ctx) {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    return;
                }
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                
                // Create high-quality noise buffer
                const bufferSize = this.ctx.sampleRate * 3; 
                this.noiseBuffer = this.ctx.createBuffer(2, bufferSize, this.ctx.sampleRate);
                for(let channel = 0; channel < 2; channel++) {
                    const data = this.noiseBuffer.getChannelData(channel);
                    for (let i = 0; i < bufferSize; i++) {
                        data[i] = (Math.random() * 2 - 1) * 0.8;
                    }
                }
                
                // ENHANCED ENGINE SOUND - Cybertruck electric motor simulation
                this.engineOsc = this.ctx.createOscillator(); 
                this.engineOsc.type = 'triangle'; // Smoother for electric motor
                this.engineOsc.frequency.value = 35; // Lower base frequency
                
                this.engineOsc2 = this.ctx.createOscillator();
                this.engineOsc2.type = 'sine'; // Pure tone for electric whine
                this.engineOsc2.frequency.value = 70;
                
                this.engineGain = this.ctx.createGain(); 
                this.engineGain.gain.value = 0;
                
                this.engineFilter = this.ctx.createBiquadFilter(); 
                this.engineFilter.type = 'lowpass'; 
                this.engineFilter.frequency.value = 250;
                this.engineFilter.Q.value = 1.5;
                
                // Connect engine chain
                const engineMix = this.ctx.createGain();
                engineMix.gain.value = 0.8;
                const engineMix2 = this.ctx.createGain();
                engineMix2.gain.value = 0.2;
                
                this.engineOsc.connect(engineMix);
                this.engineOsc2.connect(engineMix2);
                engineMix.connect(this.engineFilter);
                engineMix2.connect(this.engineFilter);
                this.engineFilter.connect(this.engineGain);
                this.engineGain.connect(this.ctx.destination);
                
                this.engineOsc.start();
                this.engineOsc2.start();

                // ENHANCED TIRE SCREECH for handbrake slides
                this.skidOsc = this.ctx.createOscillator();
                this.skidOsc.type = 'sawtooth';
                this.skidOsc.frequency.value = 150;
                
                this.skidGain = this.ctx.createGain();
                this.skidGain.gain.value = 0;
                
                this.skidFilter = this.ctx.createBiquadFilter();
                this.skidFilter.type = 'bandpass';
                this.skidFilter.frequency.value = 1200;
                this.skidFilter.Q.value = 12.0; // Very sharp for intense screech
                
                this.skidOsc.connect(this.skidFilter);
                this.skidFilter.connect(this.skidGain);
                this.skidGain.connect(this.ctx.destination);
                this.skidOsc.start();

                // HIGH-SPEED WIND
                this.windOsc = this.ctx.createOscillator();
                this.windOsc.type = 'sawtooth';
                this.windOsc.frequency.value = 50;
                
                this.windGain = this.ctx.createGain();
                this.windGain.gain.value = 0;
                
                this.windFilter = this.ctx.createBiquadFilter();
                this.windFilter.type = 'highpass';
                this.windFilter.frequency.value = 180;
                
                this.windOsc.connect(this.windFilter);
                this.windFilter.connect(this.windGain);
                this.windGain.connect(this.ctx.destination);
                this.windOsc.start();

                // Cybertruck Music
                this.bgm = new Audio('music/cybertruck.mp3');
                this.bgm.loop = true;
                this.bgm.volume = 0.35; // Balanced for enhanced SFX
                this.bgm.crossOrigin = "anonymous";
                
                this.bgm.addEventListener('canplay', () => {
                    if(this.isMusicOn) this.bgm.play().catch(e => {});
                });
            },
            
            playMusic: function() {
                if (this.bgm && this.isMusicOn && this.bgm.paused) {
                    this.bgm.play().catch(e => {});
                }
            },

            toggleMusic: function() {
                this.isMusicOn = !this.isMusicOn;
                const btn = document.getElementById('music-indicator');
                if (this.isMusicOn) {
                    if(this.bgm) this.bgm.play().catch(e => {});
                    btn.innerText = "MUSIC: ON";
                    btn.classList.remove('off');
                } else {
                    if(this.bgm) this.bgm.pause();
                    btn.innerText = "MUSIC: OFF";
                    btn.classList.add('off');
                }
            },

            toggleSfx: function() {
                this.isSfxOn = !this.isSfxOn;
                const btn = document.getElementById('sfx-indicator');
                if(this.isSfxOn) {
                    btn.innerText = "SFX: ON";
                    btn.classList.remove('off');
                } else {
                    btn.innerText = "SFX: OFF";
                    btn.classList.add('off');
                    if(this.engineGain) this.engineGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                    if(this.skidGain) this.skidGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                    if(this.windGain) this.windGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                }
            },

            // ENHANCED AUDIO UPDATE for electric Cybertruck
            updateEngine: function(speedPercent, driftIntensity) {
                if (!this.ctx || !this.isSfxOn) return;

                this.smoothSpeed = THREE.MathUtils.lerp(this.smoothSpeed, speedPercent, 0.08);
                this.smoothDrift = THREE.MathUtils.lerp(this.smoothDrift, driftIntensity, 0.12);

                // Electric motor whine (higher pitch at speed)
                const baseFreq = 35 + (this.smoothSpeed * this.smoothSpeed * 200);
                const harmFreq = baseFreq * 2.0;

                this.engineOsc.frequency.setTargetAtTime(baseFreq, this.ctx.currentTime, 0.04);
                this.engineOsc2.frequency.setTargetAtTime(harmFreq, this.ctx.currentTime, 0.06);

                // Cybertruck motor volume curve
                const engineVol = 0.015 + (this.smoothSpeed * 0.08) + (this.smoothSpeed * this.smoothSpeed * 0.06);
                this.engineGain.gain.setTargetAtTime(engineVol, this.ctx.currentTime, 0.08);

                // Filter sweep for electric motor character
                const filterFreq = 180 + (this.smoothSpeed * 1800) + (this.smoothDrift * 600);
                this.engineFilter.frequency.setTargetAtTime(filterFreq, this.ctx.currentTime, 0.08);

                // INTENSE HANDBRAKE SCREECH
                if(this.smoothDrift > 0.15) {
                    const skidVol = Math.min(this.smoothDrift * 0.35, 0.28); // Louder for dramatic effect
                    this.skidGain.gain.setTargetAtTime(skidVol, this.ctx.currentTime, 0.03);
                    
                    // Varying screech for realism
                    const skidFreq = 150 + (Math.random() * 120) + (this.smoothDrift * 80);
                    this.skidOsc.frequency.setTargetAtTime(skidFreq, this.ctx.currentTime, 0.04);
                    
                    // Dynamic filter sweep for tire screech character
                    const skidFilterFreq = 800 + (this.smoothDrift * 1600) + (Math.random() * 600);
                    this.skidFilter.frequency.setTargetAtTime(skidFilterFreq, this.ctx.currentTime, 0.06);
                } else {
                    this.skidGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.15);
                }

                // Wind noise at high speed
                if(this.smoothSpeed > 0.65) {
                    const windVol = (this.smoothSpeed - 0.65) * 0.12;
                    this.windGain.gain.setTargetAtTime(windVol, this.ctx.currentTime, 0.25);
                    
                    const windFreq = 50 + (this.smoothSpeed * 35) + (Math.random() * 15);
                    this.windOsc.frequency.setTargetAtTime(windFreq, this.ctx.currentTime, 0.18);
                } else {
                    this.windGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.4);
                }
            },
            
            playLand: function(intensity) {
                if (!this.ctx || !this.isSfxOn) return;
                const src = this.ctx.createBufferSource(); 
                src.buffer = this.noiseBuffer;
                
                const gain = this.ctx.createGain(); 
                const startVol = Math.min(intensity * 0.25, 0.35);
                gain.gain.setValueAtTime(startVol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.35);
                
                const filter = this.ctx.createBiquadFilter(); 
                filter.type = 'lowpass';
                filter.frequency.setValueAtTime(350, this.ctx.currentTime); 
                filter.frequency.exponentialRampToValueAtTime(70, this.ctx.currentTime + 0.25);
                
                src.connect(filter); 
                filter.connect(gain); 
                gain.connect(this.ctx.destination);
                src.start(); 
                src.stop(this.ctx.currentTime + 0.35);
            },

            playCollect: function() {
                if (!this.ctx || !this.isSfxOn) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(700, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1600, this.ctx.currentTime + 0.12);
                osc.frequency.exponentialRampToValueAtTime(900, this.ctx.currentTime + 0.35);
                
                gain.gain.setValueAtTime(0.18, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.55);
                
                osc.connect(gain); 
                gain.connect(this.ctx.destination);
                osc.start(); 
                osc.stop(this.ctx.currentTime + 0.55);
            }
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); 
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0xdcb183, 15, 250); 
            
            camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true; 
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; 
            renderer.toneMappingExposure = 1.3;
            container.appendChild(renderer.domElement);

            // Enhanced lighting for Cybertruck
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); 
            scene.add(ambientLight);
            
            const dirLight = new THREE.DirectionalLight(0xffffff, 2.0); 
            dirLight.position.set(40, 120, 60); 
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; 
            dirLight.shadow.mapSize.height = 4096; 
            dirLight.shadow.bias = -0.0002;
            dirLight.shadow.camera.near = 1;
            dirLight.shadow.camera.far = 400;
            dirLight.shadow.camera.left = -120;
            dirLight.shadow.camera.right = 120;
            dirLight.shadow.camera.top = 120;
            dirLight.shadow.camera.bottom = -120;
            scene.add(dirLight);

            createTerrain();
            createRings(); 
            loadModels();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { onKey(e, true); sfx.init(); sfx.playMusic(); });
            document.addEventListener('keyup', (e) => onKey(e, false));
            
            const camInd = document.getElementById('camera-indicator'); 
            camInd.addEventListener('click', (e) => { e.stopPropagation(); switchCamera(); });
            
            const musInd = document.getElementById('music-indicator');
            musInd.addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleMusic(); });

            const sfxInd = document.getElementById('sfx-indicator');
            sfxInd.addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleSfx(); });

            controls.init(); 
            animate();
        }

        function updateProgress() {
            const total = Math.round((progressCyber + progressTree) / 2);
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('loading-text');
            if(bar) bar.style.width = total + "%";
            if(text && text.className !== 'error-msg') text.innerText = "DOWNLOADING... " + total + "%";
        }

        function reportError(name) {
             const text = document.getElementById('loading-text');
             if(text) { text.innerText = "ERROR: " + name + " NOT FOUND. USING FALLBACK."; text.className = "error-msg"; }
        }

        function createRings() {
            const geo = new THREE.TorusGeometry(0.9, 0.18, 8, 16);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF00, 
                metalness: 0.2, 
                roughness: 0.1, 
                emissive: 0xFFFF00, 
                emissiveIntensity: 0.9
            });

            for(let i=0; i<25; i++) {
                const ring = new THREE.Mesh(geo, mat);
                const x = (Math.random() - 0.5) * 320;
                const z = (Math.random() - 0.5) * 320;
                const y = getTerrainHeight(x, z);
                ring.position.set(x, y + 0.3, z); 
                ring.rotation.y = Math.random() * Math.PI;
                ring.castShadow = true;
                scene.add(ring);
                rings.push(ring);
            }
        }

        function loadModels() {
            const loader = new FBXLoader();
            bikeGroup = new THREE.Group(); 
            scene.add(bikeGroup); 

            // 1. Load Cybertruck.fbx
            loader.load('Cybertruck.fbx', (object) => {
                object.scale.set(0.008, 0.008, 0.008); // Slightly larger for better presence
                object.rotation.y = 0; 
                object.traverse((child) => { 
                    if (child.isMesh) { 
                        child.castShadow = true; 
                        child.receiveShadow = true; 
                        // Cybertruck materials
                        if(child.material) {
                            child.material.metalness = 0.8; // High metalness for steel body
                            child.material.roughness = 0.2; // Smooth steel finish
                        }
                    } 
                });
                bikeGroup.add(object);
                addExhaust();
                addTireSmoke();
                assetsLoaded++;
                checkLoading();
            }, (xhr) => { 
                if (xhr.lengthComputable) { 
                    progressCyber = (xhr.loaded / xhr.total) * 100; 
                    updateProgress(); 
                } else { 
                    progressCyber = 60; 
                    updateProgress(); 
                }
            }, (error) => { 
                console.warn("Cybertruck.fbx missing."); 
                reportError("Cybertruck.fbx"); 
                createFallbackCybertruck(); 
                assetsLoaded++; 
                checkLoading(); 
            });

            // 2. Load FBX Tree
            loader.load('fbx/Tree.fbx', (object) => {
                const count = 90; 
                const dummy = new THREE.Object3D();
                const transforms = [];
                for(let i=0; i<count; i++) {
                    const x = (Math.random() - 0.5) * 220;
                    const z = (Math.random() - 0.5) * 220;
                    if (Math.abs(x) < 25 && Math.abs(z) < 25) { i--; continue; } 
                    const y = getTerrainHeight(x, z);
                    const s = 0.016 * (0.7 + Math.random() * 0.6); 
                    dummy.position.set(x, y, z);
                    dummy.rotation.set(0, Math.random() * Math.PI * 2, 0); 
                    dummy.scale.set(s, s, s);
                    dummy.updateMatrix();
                    transforms.push(dummy.matrix.clone());
                    obstacles.push({ x: x, z: z, radius: 1.6 });
                }
                object.traverse((child) => {
                    if (child.isMesh) {
                        const instancedMesh = new THREE.InstancedMesh(child.geometry, child.material, count);
                        instancedMesh.castShadow = true;
                        instancedMesh.receiveShadow = true;
                        for(let i=0; i<count; i++) instancedMesh.setMatrixAt(i, transforms[i]);
                        instancedMesh.instanceMatrix.needsUpdate = true;
                        scene.add(instancedMesh);
                    }
                });
                assetsLoaded++;
                checkLoading();
            }, (xhr) => { 
                if (xhr.lengthComputable) { 
                    progressTree = (xhr.loaded / xhr.total) * 100; 
                    updateProgress(); 
                } else { 
                    progressTree = 50; 
                    updateProgress(); 
                }
            }, (err) => { 
                console.warn("Tree FBX missing."); 
                reportError("Tree.fbx"); 
                createFallbackTrees(); 
                assetsLoaded++; 
                checkLoading(); 
            });

            createProceduralPines();
            createRocks();
        }

        function createProceduralPines() {
            const trunkGeo = new THREE.CylinderGeometry(0.25, 0.45, 1.8, 6); 
            trunkGeo.translate(0, 0.9, 0);
            const leaves1 = new THREE.ConeGeometry(1.4, 1.8, 6); 
            leaves1.translate(0, 2.2, 0);
            const leaves2 = new THREE.ConeGeometry(1.0, 1.4, 6); 
            leaves2.translate(0, 3.0, 0);
            const leaves3 = new THREE.ConeGeometry(0.7, 1.1, 6); 
            leaves3.translate(0, 3.8, 0);
            
            const count = 85;
            const dummy = new THREE.Object3D();
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x2d1f0f, roughness: 0.95});
            const leafMat = new THREE.MeshStandardMaterial({color: 0x0f3d1f, roughness: 0.85});
            const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, count);
            const leafGeo = BufferGeometryUtils.mergeGeometries([leaves1, leaves2, leaves3]);
            const leafMesh = new THREE.InstancedMesh(leafGeo, leafMat, count);
            
            trunkMesh.castShadow = true; 
            trunkMesh.receiveShadow = true;
            leafMesh.castShadow = true; 
            leafMesh.receiveShadow = true;
            
            for(let i=0; i<count; i++) {
                const x = (Math.random() - 0.5) * 340; 
                const z = (Math.random() - 0.5) * 340;
                if(Math.abs(x) < 25 && Math.abs(z) < 25) { i--; continue; }
                const y = getTerrainHeight(x, z); 
                const s = 0.9 + Math.random() * 0.7;
                dummy.position.set(x, y, z); 
                dummy.rotation.y = Math.random() * Math.PI; 
                dummy.scale.set(s,s,s); 
                dummy.updateMatrix();
                trunkMesh.setMatrixAt(i, dummy.matrix); 
                leafMesh.setMatrixAt(i, dummy.matrix);
                obstacles.push({x:x, z:z, radius: 1.2});
            }
            scene.add(trunkMesh); 
            scene.add(leafMesh);
        }

        function createFallbackCybertruck() {
            // Angular Cybertruck-like shape
            const bodyGeo = new THREE.BoxGeometry(1.2, 0.6, 2.2); 
            const bodyMat = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0, 
                metalness: 0.8, 
                roughness: 0.2
            }); 
            const body = new THREE.Mesh(bodyGeo, bodyMat); 
            body.position.set(0, 0.8, 0);
            
            // Cybertruck cab
            const cabGeo = new THREE.BoxGeometry(1.0, 0.8, 1.0);
            const cab = new THREE.Mesh(cabGeo, bodyMat);
            cab.position.set(0, 1.2, 0.3);
            
            bikeGroup.add(body);
            bikeGroup.add(cab);
            addExhaust();
            addTireSmoke();
        }

        function createFallbackTrees() {
            const geo = new THREE.ConeGeometry(1.2, 4.5, 8); 
            const mat = new THREE.MeshStandardMaterial({color: 0x1a472a});
            for(let i=0; i<35; i++) { 
                const x = (Math.random() - 0.5) * 220; 
                const z = (Math.random() - 0.5) * 220; 
                const y = getTerrainHeight(x, z); 
                const mesh = new THREE.Mesh(geo, mat); 
                mesh.position.set(x, y+2.2, z); 
                scene.add(mesh); 
                obstacles.push({ x: x, z: z, radius: 1.5 }); 
            }
        }

        function addExhaust() { 
            const exhaustPoint = new THREE.Object3D(); 
            exhaustPoint.position.set(0, 0.4, -1.5); 
            exhaustPoint.name = "exhaust"; 
            bikeGroup.add(exhaustPoint); 
        }

        function addTireSmoke() {
            // Cybertruck tire positions
            const leftRear = new THREE.Object3D();
            leftRear.position.set(-0.6, 0.2, -0.8);
            leftRear.name = "leftRear";
            bikeGroup.add(leftRear);

            const rightRear = new THREE.Object3D();
            rightRear.position.set(0.6, 0.2, -0.8);
            rightRear.name = "rightRear";
            bikeGroup.add(rightRear);
        }
        
        function checkLoading() { 
            if (assetsLoaded >= assetsTotal) { 
                sfx.init(); 
                sfx.playMusic();
                setTimeout(() => { 
                    document.getElementById('loading').style.display = 'none'; 
                }, 600); 
            } 
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(450, 450, 450, 450); 
            geometry.rotateX(-Math.PI / 2); 
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i]; 
                const z = positions[i + 2];
                const y = (Math.sin(x * 0.025) * 6) + (Math.cos(z * 0.025) * 6) + (Math.sin(x * 0.08 + z * 0.08) * 2) + (Math.random() * 0.3);
                const dist = Math.sqrt(x*x + z*z); 
                let bowl = 0; 
                if(dist > 120) bowl = (dist - 120) * 0.12; 
                positions[i + 1] = y + bowl;
            }
            geometry.computeVertexNormals();
            
            // Enhanced dirt terrain
            const canvas = document.createElement('canvas'); 
            canvas.width = 1024; 
            canvas.height = 1024; 
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = '#8B5A2B'; 
            ctx.fillRect(0,0,1024,1024);
            
            // More detailed texture
            for(let i=0; i<60000; i++) {
                const shade = Math.random(); 
                if(shade > 0.75) ctx.fillStyle = '#B07040'; 
                else if (shade > 0.5) ctx.fillStyle = '#5C4033'; 
                else if (shade > 0.25) ctx.fillStyle = '#556B2F';
                else ctx.fillStyle = '#704214';
                
                const x = Math.random() * 1024; 
                const y = Math.random() * 1024; 
                const size = Math.random() * 4 + 0.5; 
                ctx.fillRect(x, y, size, size);
            }
            
            const tex = new THREE.CanvasTexture(canvas); 
            tex.wrapS = THREE.RepeatWrapping; 
            tex.wrapT = THREE.RepeatWrapping; 
            tex.repeat.set(12, 12);
            
            const material = new THREE.MeshStandardMaterial({ 
                map: tex, 
                roughness: 0.95,
                metalness: 0.0
            });
            
            terrainMesh = new THREE.Mesh(geometry, material); 
            terrainMesh.receiveShadow = true; 
            scene.add(terrainMesh);
        }

        function getTerrainHeight(x, z) { 
            const raycaster = new THREE.Raycaster(); 
            raycaster.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0)); 
            const intersects = raycaster.intersectObject(terrainMesh); 
            return intersects.length > 0 ? intersects[0].point.y : 0; 
        }
        
        function createRocks() {
            const rockGeo = new THREE.DodecahedronGeometry(1.2, 0); 
            const rockMat = new THREE.MeshStandardMaterial({ 
                color: 0x555555, 
                roughness: 0.95,
                metalness: 0.05 
            });
            
            for(let i=0; i< 40; i++) { 
                const x = (Math.random() - 0.5) * 380; 
                const z = (Math.random() - 0.5) * 380; 
                const y = getTerrainHeight(x, z); 
                const rock = new THREE.Mesh(rockGeo, rockMat); 
                rock.position.set(x, y + 0.6, z); 
                rock.scale.set(0.8 + Math.random(), 0.8 + Math.random(), 0.8 + Math.random()); 
                rock.rotation.set(Math.random(), Math.random(), Math.random()); 
                rock.castShadow = true; 
                scene.add(rock); 
                obstacles.push({ x: x, z: z, radius: 1.1 }); 
            }
        }
        
        function createDust() {
            if(!bikeGroup) return; 
            const exhaust = bikeGroup.getObjectByName("exhaust"); 
            if (!exhaust) return; 
            if (Math.abs(speed) < 0.15) return;
            
            const pos = new THREE.Vector3(); 
            exhaust.getWorldPosition(pos); 
            const geo = new THREE.BoxGeometry(0.12, 0.12, 0.12); 
            const mat = new THREE.MeshBasicMaterial({ 
                color: 0x9b8e76, 
                transparent: true, 
                opacity: 0.25
            }); 
            const p = new THREE.Mesh(geo, mat); 
            p.position.copy(pos); 
            p.position.x += (Math.random() - 0.5) * 0.5; 
            p.position.z += (Math.random() - 0.5) * 0.3;
            
            const gH = getTerrainHeight(pos.x, pos.z); 
            if(p.position.y < gH) p.position.y = gH + 0.15; 
            
            scene.add(p); 
            particles.push({ 
                mesh: p, 
                life: 1.2,
                velocity: new THREE.Vector3(
                    (Math.random() - 0.5) * 0.025,
                    0.008 + Math.random() * 0.025,
                    (Math.random() - 0.5) * 0.025
                )
            });
        }

        function createTireSmoke() {
            if(!bikeGroup || !isDriftActive) return;
            
            const leftRear = bikeGroup.getObjectByName("leftRear");
            const rightRear = bikeGroup.getObjectByName("rightRear");
            
            [leftRear, rightRear].forEach(tire => {
                if(!tire) return;
                
                const pos = new THREE.Vector3();
                tire.getWorldPosition(pos);
                
                // More intense smoke during handbrake slides
                for(let i = 0; i < 3; i++) {
                    const geo = new THREE.BoxGeometry(0.08, 0.08, 0.08);
                    const mat = new THREE.MeshBasicMaterial({
                        color: 0xaaaaaa,
                        transparent: true,
                        opacity: 0.7
                    });
                    
                    const p = new THREE.Mesh(geo, mat);
                    p.position.copy(pos);
                    p.position.x += (Math.random() - 0.5) * 0.4;
                    p.position.z += (Math.random() - 0.5) * 0.4;
                    p.position.y += Math.random() * 0.15;
                    
                    scene.add(p);
                    particles.push({
                        mesh: p,
                        life: 0.9,
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.04,
                            0.015 + Math.random() * 0.025,
                            (Math.random() - 0.5) * 0.04
                        ),
                        isTireSmoke: true
                    });
                }
            });
        }

        function updateParticles() { 
            for (let i = particles.length - 1; i >= 0; i--) { 
                const p = particles[i]; 
                p.life -= p.isTireSmoke ? 0.025 : 0.018; 
                
                if(p.velocity) {
                    p.mesh.position.add(p.velocity);
                    p.velocity.multiplyScalar(0.97);
                } else {
                    p.mesh.position.y += 0.015; 
                }
                
                p.mesh.scale.multiplyScalar(1.025); 
                p.mesh.material.opacity = p.life * (p.isTireSmoke ? 0.7 : 0.25); 
                p.mesh.rotation.x += 0.08; 
                p.mesh.rotation.z += 0.04;
                
                if (p.life <= 0) { 
                    scene.remove(p.mesh); 
                    particles.splice(i, 1); 
                } 
            } 
        }

        function onKey(e, pressed) { 
            const k = e.key.toLowerCase(); 
            if (k === 'w' || k === 'arrowup') keys.w = pressed; 
            if (k === 's' || k === 'arrowdown') keys.s = pressed; 
            if (k === 'a' || k === 'arrowleft') keys.a = pressed; 
            if (k === 'd' || k === 'arrowright') keys.d = pressed; 
            if (k === ' ') { keys.space = pressed; handbrakeHeld = pressed; }
        }
        
        function switchCamera() { 
            activeCameraMode = (activeCameraMode + 1) % 2; 
            const ind = document.getElementById('camera-indicator'); 
            let nextMode = (activeCameraMode + 1) % 2;
            let label = "";
            switch(nextMode) {
                case 0: label = "CAM: CHASE VIEW"; break;
                case 1: label = "CAM: TOP VIEW"; break;
            }
            ind.innerText = label;
        }
        
        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight); 
        }

        function checkCollisions(newX, newZ) { 
            const bikeRadius = 0.7; // Larger for Cybertruck
            for(let obs of obstacles) { 
                const dx = newX - obs.x; 
                const dz = newZ - obs.z; 
                const dist = Math.sqrt(dx*dx + dz*dz); 
                if (dist < (bikeRadius + obs.radius)) return true; 
            } 
            return false; 
        }

        function checkRings() {
            const playerPos = bikeGroup.position;
            for(let i = rings.length - 1; i >= 0; i--) {
                const ring = rings[i];
                ring.rotation.y += 0.04; 
                const dx = playerPos.x - ring.position.x;
                const dy = (playerPos.y + 0.8) - ring.position.y; 
                const dz = playerPos.z - ring.position.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                if (dist < 2.2) {
                    scene.remove(ring); 
                    rings.splice(i, 1); 
                    sfx.playCollect(); 
                    battery = Math.min(100, battery + RING_CHARGE);
                }
            }
        }

        function updateBattery() {
            if (Math.abs(speed) > 0.01) {
                battery -= BATTERY_DRAIN;
                if (battery < 0) battery = 0;
            }
            
            const bar = document.getElementById('battery-bar');
            const txt = document.getElementById('battery-text');
            bar.style.width = battery + "%";
            txt.innerText = "BATTERY: " + Math.round(battery) + "%";
            
            if (battery <= 0) {
                speed *= 0.94; 
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            if (time - lastTime >= 1000) { 
                document.getElementById('fps').innerText = frameCount + " FPS"; 
                frameCount = 0; 
                lastTime = time; 
            }
            frameCount++;

            let throttleInput = 0;
            if (keys.w) throttleInput += 1;
            if (keys.s) throttleInput -= 1;
            if (Math.abs(analogThrottle) > 0.1) throttleInput += analogThrottle;

            // Normal acceleration (no speed reduction from handbrake)
            if (battery > 0) { 
                if (throttleInput > 0) speed += ACCEL * throttleInput; 
            }
            if (throttleInput < 0) speed += ACCEL * throttleInput * 0.8; // Reverse slightly slower
            
            let turnInput = 0; 
            if (keys.a) turnInput += 1; 
            if (keys.d) turnInput -= 1; 
            turnInput += analogSteering;

            // HANDBRAKE SLIDE PHYSICS
            const absSpeed = Math.abs(speed);
            const speedPercent = Math.min(absSpeed / MAX_SPEED, 1.0);
            
            // Handbrake behavior: maintain forward speed, add lateral slide
            if (handbrakeHeld && absSpeed > MIN_DRIFT_SPEED && Math.abs(turnInput) > 0.2) {
                isDriftActive = true;
                driftIntensity = Math.min(driftIntensity + 0.08, 1.0);
                
                // KEEP forward momentum (key difference!)
                speed *= HANDBRAKE_FORWARD_RETENTION; // Only slight forward speed loss
                
                // Add strong lateral slide based on turn input and speed
                const slideAmount = turnInput * HANDBRAKE_SLIDE_FORCE * (1 + speedPercent * SLIDE_AMPLIFICATION);
                const slideDir = new THREE.Vector3(-1, 0, 0); 
                slideDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                slideDir.multiplyScalar(slideAmount);
                
                // Accumulate lateral velocity for sustained slides
                lateralVelocity.add(slideDir);
                lateralVelocity.multiplyScalar(LATERAL_FRICTION); // Gradual decay
                
            } else {
                // End handbrake slide
                isDriftActive = false;
                driftIntensity = Math.max(driftIntensity - 0.12, 0.0);
                
                // Normal coasting friction when not handbraking
                speed *= FRICTION;
                lateralVelocity.multiplyScalar(0.85); // Faster lateral decay when not sliding
            }

            // Update drift UI
            const driftIndicator = document.getElementById('drift-indicator');
            if (isDriftActive && driftIntensity > 0.25) {
                driftIndicator.classList.add('active');
            } else {
                driftIndicator.classList.remove('active');
            }

            if (bikeGroup && Math.abs(speed) > 0.05) {
                // Normal turning (still applies during handbrake)
                bikeGroup.rotation.y += turnInput * TURN_SPEED;
                
                // COMBINE FORWARD AND LATERAL MOVEMENT
                const forwardDir = new THREE.Vector3(0, 0, speed);
                forwardDir.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                
                // Total velocity = forward movement + lateral slide
                velocity = forwardDir.clone().add(lateralVelocity);
                
                const nextPos = bikeGroup.position.clone().add(velocity);

                if (checkCollisions(nextPos.x, nextPos.z)) { 
                    speed = -speed * 0.4; 
                    lateralVelocity.multiplyScalar(0.2); // Reduce slide on collision
                    sfx.playLand(1.2); 
                } else { 
                    bikeGroup.position.copy(nextPos);
                }

                // Map boundaries
                if (bikeGroup.position.x > MAP_LIMIT) { 
                    bikeGroup.position.x = MAP_LIMIT; 
                    speed = 0; 
                    lateralVelocity.x = 0; 
                }
                if (bikeGroup.position.x < -MAP_LIMIT) { 
                    bikeGroup.position.x = -MAP_LIMIT; 
                    speed = 0; 
                    lateralVelocity.x = 0; 
                }
                if (bikeGroup.position.z > MAP_LIMIT) { 
                    bikeGroup.position.z = MAP_LIMIT; 
                    speed = 0; 
                    lateralVelocity.z = 0; 
                }
                if (bikeGroup.position.z < -MAP_LIMIT) { 
                    bikeGroup.position.z = -MAP_LIMIT; 
                    speed = 0; 
                    lateralVelocity.z = 0; 
                }

                // Enhanced audio for Cybertruck
                sfx.updateEngine(speedPercent, driftIntensity);
                
                checkRings();
                updateBattery();

                // Ground following
                const groundH = getTerrainHeight(bikeGroup.position.x, bikeGroup.position.z);
                verticalVelocity -= GRAVITY; 
                bikeGroup.position.y += verticalVelocity;

                if (bikeGroup.position.y < groundH) { 
                    const landingForce = Math.abs(verticalVelocity);
                    bikeGroup.position.y = groundH; 
                    verticalVelocity = landingForce * 0.08;
                    if(landingForce > 0.12) sfx.playLand(landingForce);
                }

                // Enhanced Cybertruck tilting
                const aheadV = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                const nextXPos = bikeGroup.position.x + aheadV.x; 
                const nextZPos = bikeGroup.position.z + aheadV.z; 
                const nextH = getTerrainHeight(nextXPos, nextZPos);
                
                const pitchAngle = Math.atan2(nextH - groundH, 1.0); 
                bikeGroup.rotation.x = THREE.MathUtils.lerp(bikeGroup.rotation.x, -pitchAngle, 0.18);
                
                // Enhanced roll during slides
                const targetRoll = turnInput * 0.35 + (driftIntensity * turnInput * 0.5); 
                bikeGroup.rotation.z = THREE.MathUtils.lerp(bikeGroup.rotation.z, targetRoll, 0.12);

                // Dynamic camera with slide-responsive positioning
                const targetPos = bikeGroup.position.clone();
                let camOffset = new THREE.Vector3();
                let lookOffset = new THREE.Vector3(0, 1.2, 0);

                const cameraShake = driftIntensity * 0.15;
                const speedOffset = speedPercent * 2.5;

                switch(activeCameraMode) {
                    case 0: // Dynamic Chase with slide tracking
                        camOffset.set(
                            (Math.random() - 0.5) * cameraShake - lateralVelocity.x * 3,
                            4.5 + speedOffset,
                            -9 - speedOffset
                        );
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                        break;
                    case 1: // Top Down
                        camOffset.set(
                            (Math.random() - 0.5) * cameraShake,
                            28 + speedOffset * 2,
                            -3
                        );
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                        break;
                }

                const camPos = targetPos.clone().add(camOffset);
                const camGroundH = getTerrainHeight(camPos.x, camPos.z);
                if (camPos.y < camGroundH + 1.5) camPos.y = camGroundH + 1.5;

                camera.position.lerp(camPos, 0.14);
                camera.lookAt(targetPos.clone().add(lookOffset));
            }

            // Enhanced particle generation
            if(frameCount % 3 === 0) createDust();
            if(isDriftActive && frameCount % 1 === 0) createTireSmoke(); // Continuous smoke during slides
            
            updateParticles();
            
            const displaySpeed = Math.abs(Math.round(speed * 90));
            document.getElementById('speed').innerText = displaySpeed + " KM/H";
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
