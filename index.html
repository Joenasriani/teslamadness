<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tesla Madness 1998 - Real Drift</title>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: max(20px, env(safe-area-inset-top)); 
            left: max(20px, env(safe-area-inset-left));
            color: #ffcc00;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            z-index: 10;
            width: auto;
            max-width: 50%;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        h1 { margin: 0; font-size: clamp(14px, 4vw, 24px); letter-spacing: 1px; text-transform: uppercase; font-weight: bold; white-space: nowrap; line-height: 1.2; }
        p { margin: 5px 0; font-size: clamp(9px, 2.5vw, 14px); color: #fff; }
        .accent { color: #00ff00; }
        
        .battery-container {
            margin-top: 25px; 
            width: 100%;
            max-width: 200px;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #fff;
            position: relative;
        }
        #battery-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.2s;
        }
        #battery-text {
            position: absolute; top: -18px; right: 0; font-size: clamp(9px, 2.5vw, 12px); color: #fff; text-shadow: 1px 1px 0 #000;
        }
        
        .hud-stats {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            text-align: right;
            color: #fff;
            z-index: 10;
            pointer-events: none;
            font-size: clamp(12px, 3.5vw, 16px);
            max-width: 40%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        .hud-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffcc00;
            padding: 5px 8px;
            color: #ffcc00;
            font-weight: bold;
            text-transform: uppercase;
            font-size: clamp(9px, 2.5vw, 12px);
            pointer-events: auto; 
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
            text-shadow: 1px 1px 0 #000;
        }
        
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: clamp(280px, 60vw, 500px);
            background: black; padding: 20px; border: 2px solid #ffcc00;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; text-align: center; box-shadow: 0 0 20px rgba(255, 204, 0, 0.2);
        }
        .loading-title { color: white; font-size: clamp(16px, 4vw, 20px); margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .progress-track { width: 100%; height: 20px; background: #222; border: 1px solid #555; margin-bottom: 10px; position: relative; }
        #progress-bar { width: 0%; height: 100%; background: #ffcc00; transition: width 0.2s; }
        #loading-text { color: #aaa; font-size: 12px; }
        .error-msg { color: #ff3333 !important; }

        .touch-controls {
            position: absolute; bottom: max(20px, env(safe-area-inset-bottom)); left: 0; width: 100%; height: auto; pointer-events: none; z-index: 50;
            display: flex; justify-content: space-between; padding-left: max(20px, env(safe-area-inset-left)); padding-right: max(20px, env(safe-area-inset-right)); box-sizing: border-box; align-items: flex-end;
        }

        .control-zone { width: 45%; height: 250px; pointer-events: auto; touch-action: none; position: relative; }
        .zone-hint { position: absolute; bottom: 20px; color: rgba(255,255,255,0.3); font-size: 12px; pointer-events: none; font-weight: bold; text-transform: uppercase; }
        .hint-left { left: 0; } .hint-right { right: 0; text-align: right; }

        .touch-feedback-base {
            position: absolute; width: 100px; height: 100px; background: rgba(255, 255, 255, 0.1); border: 2px solid rgba(255, 204, 0, 0.3); border-radius: 50%; transform: translate(-50%, -50%); display: none; pointer-events: none;
        }
        .touch-feedback-knob {
            position: absolute; width: 50px; height: 50px; background: rgba(255, 204, 0, 0.8); border-radius: 50%; transform: translate(-50%, -50%); left: 50%; top: 50%; box-shadow: 0 0 15px rgba(255, 204, 0, 0.6);
        }

        /* HANDBRAKE VISUAL */
        #brake-visual .touch-feedback-knob {
            width: 90px; height: 90px;
            background: rgba(255, 50, 50, 0.6);
            border: 2px solid #ff3333;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            display: flex; align-items: center; justify-content: center;
            color: white; font-weight: bold; font-size: 14px;
        }
        #brake-visual .touch-feedback-knob::after { content: "HANDBRAKE"; }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loading-title">CHARGING BATTERIES...</div>
        <div class="progress-track">
            <div id="progress-bar"></div>
        </div>
        <div id="loading-text">LOADING ASSETS...</div>
    </div>

    <div id="ui-layer">
        <h1>TESLA MADNESS '98</h1>
        <div class="battery-container">
            <div id="battery-bar"></div>
            <div id="battery-text">BATTERY: 100%</div>
        </div>
        <p>COLLECT <span style="color:gold">GOLD RINGS</span></p>
    </div>

    <div class="hud-stats">
        <div id="speed">0 KM/H</div>
        <div id="fps">60 FPS</div>
        <div id="camera-indicator" class="hud-btn">CAM: FAR CHASE</div>
        <div id="music-indicator" class="hud-btn">MUSIC: ON</div>
        <div id="sfx-indicator" class="hud-btn">SFX: ON</div>
    </div>

    <div class="touch-controls">
        <div id="joystick-zone" class="control-zone">
            <div class="zone-hint hint-left">MOVE & STEER</div>
            <div class="touch-feedback-base" id="joy-visual">
                <div class="touch-feedback-knob" id="joy-knob"></div>
            </div>
        </div>
        <div id="brake-zone" class="control-zone">
            <div class="zone-hint hint-right">HOLD TO DRIFT</div>
            <div class="touch-feedback-base" id="brake-visual">
                <div class="touch-feedback-knob"></div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer;
        let bikeGroup, bikeVisuals, terrainMesh;
        
        // PHYSICS VARIABLES
        let speed = 0;
        let velocityVector = new THREE.Vector3(); // Actual movement direction
        let facingVector = new THREE.Vector3(0, 0, 1); // Where the nose points
        let verticalVelocity = 0; 
        
        let particles = [];
        let rings = []; 
        let frameCount = 0;
        let lastTime = 0;
        let isAirborne = false;
        let assetsLoaded = 0;
        let assetsTotal = 2; 
        let obstacles = [];
        
        let progressMoto = 0;
        let progressTree = 0;
        let battery = 100;
        
        // TUNING
        const BATTERY_DRAIN = 0.05; 
        const RING_CHARGE = 20;
        const MAX_SPEED = 1.4;
        const ACCEL = 0.025;
        const FRICTION = 0.98; // Ground friction
        const DRIFT_FRICTION = 0.99; // Less friction when drifting (sliding)
        const TURN_SPEED = 0.05;
        const GRAVITY = 0.04; 
        const MAP_LIMIT = 195; 
        
        const keys = { w: false, a: false, s: false, d: false, space: false, brake: false };
        let activeCameraMode = 0; 
        let analogSteering = 0;
        let analogThrottle = 0; 

        // --- JOYSTICK ---
        const joystick = {
            active: false, origin: { x: 0, y: 0 }, maxDist: 50,
            init: function() {
                const zone = document.getElementById('joystick-zone');
                const visual = document.getElementById('joy-visual');
                const knob = document.getElementById('joy-knob');
                
                zone.addEventListener('touchstart', (e) => {
                    e.preventDefault(); const touch = e.changedTouches[0]; this.active = true;
                    const rect = zone.getBoundingClientRect(); this.origin.x = touch.clientX - rect.left; this.origin.y = touch.clientY - rect.top;
                    visual.style.display = 'block'; visual.style.left = this.origin.x + 'px'; visual.style.top = this.origin.y + 'px'; knob.style.transform = `translate(-50%, -50%)`;
                    sfx.init(); sfx.playMusic();
                }, { passive: false });

                zone.addEventListener('touchmove', (e) => {
                    if (!this.active) return; e.preventDefault(); const touch = e.changedTouches[0]; const rect = zone.getBoundingClientRect();
                    let dx = (touch.clientX - rect.left) - this.origin.x; let dy = (touch.clientY - rect.top) - this.origin.y;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > this.maxDist) { const angle = Math.atan2(dy, dx); dx = Math.cos(angle) * this.maxDist; dy = Math.sin(angle) * this.maxDist; }
                    knob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    analogSteering = -(dx / this.maxDist); analogThrottle = -(dy / this.maxDist);
                }, { passive: false });

                const end = () => { this.active = false; visual.style.display = 'none'; analogSteering = 0; analogThrottle = 0; };
                zone.addEventListener('touchend', end); zone.addEventListener('touchcancel', end);

                // HANDBRAKE UI
                const brakeZone = document.getElementById('brake-zone');
                const brakeVisual = document.getElementById('brake-visual');
                brakeZone.addEventListener('touchstart', (e) => {
                    e.preventDefault(); const touch = e.changedTouches[0]; keys.brake = true; sfx.init(); sfx.playMusic();
                    if(window.navigator.vibrate) window.navigator.vibrate(10);
                    const rect = brakeZone.getBoundingClientRect();
                    brakeVisual.style.display = 'block'; brakeVisual.style.left = (touch.clientX - rect.left) + 'px'; brakeVisual.style.top = (touch.clientY - rect.top) + 'px';
                }, { passive: false });
                const endBrake = (e) => { e.preventDefault(); keys.brake = false; brakeVisual.style.display = 'none'; };
                brakeZone.addEventListener('touchend', endBrake); brakeZone.addEventListener('touchcancel', endBrake);
            }
        };

        const sfx = {
            ctx: null, engineOsc: null, engineGain: null, filter: null, noiseBuffer: null, skidOsc: null, skidGain: null, bgm: null, isMusicOn: true, isSfxOn: true,
            init: function() {
                if (this.ctx) { if (this.ctx.state === 'suspended') this.ctx.resume(); return; }
                const AC = window.AudioContext || window.webkitAudioContext; this.ctx = new AC();
                const bufferSize = this.ctx.sampleRate * 2; this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = this.noiseBuffer.getChannelData(0); for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                this.engineOsc = this.ctx.createOscillator(); this.engineOsc.type = 'triangle'; this.engineOsc.frequency.value = 60;
                this.engineGain = this.ctx.createGain(); this.engineGain.gain.value = 0;
                this.filter = this.ctx.createBiquadFilter(); this.filter.type = 'lowpass'; this.filter.frequency.value = 400;
                this.engineOsc.connect(this.filter); this.filter.connect(this.engineGain); this.engineGain.connect(this.ctx.destination);
                this.engineOsc.start();

                this.skidOsc = this.ctx.createOscillator(); this.skidOsc.type = 'sawtooth'; this.skidOsc.frequency.value = 150;
                this.skidGain = this.ctx.createGain(); this.skidGain.gain.value = 0;
                this.skidOsc.connect(this.skidGain); this.skidGain.connect(this.ctx.destination);
                this.skidOsc.start();

                this.bgm = new Audio('music/cybertruck.mp3'); this.bgm.loop = true; this.bgm.volume = 0.6;
            },
            playMusic: function() { if (this.bgm && this.isMusicOn && this.bgm.paused) this.bgm.play().catch(e=>{}); },
            toggleMusic: function() {
                this.isMusicOn = !this.isMusicOn; const btn = document.getElementById('music-indicator');
                if (this.isMusicOn) { if(this.bgm) this.bgm.play(); btn.innerText = "MUSIC: ON"; btn.classList.remove('off'); } 
                else { if(this.bgm) this.bgm.pause(); btn.innerText = "MUSIC: OFF"; btn.classList.add('off'); }
            },
            toggleSfx: function() {
                this.isSfxOn = !this.isSfxOn; const btn = document.getElementById('sfx-indicator');
                if(this.isSfxOn) { btn.innerText = "SFX: ON"; btn.classList.remove('off'); } 
                else { btn.innerText = "SFX: OFF"; btn.classList.add('off'); if(this.engineGain) this.engineGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1); }
            },
            updateEngine: function(speedPercent, isSkidding) {
                if (!this.ctx || !this.isSfxOn) return;
                this.engineOsc.frequency.setTargetAtTime(60 + (speedPercent * 300), this.ctx.currentTime, 0.1);
                const vol = (0.05 + (speedPercent * 0.1)) * 0.3; 
                this.engineGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
                this.filter.frequency.setTargetAtTime(200 + (speedPercent * 3000), this.ctx.currentTime, 0.1);
                // Drift sound reduced by 60% (0.15 * 0.4 = 0.06)
                const targetSkidVol = isSkidding ? 0.06 : 0;
                this.skidGain.gain.setTargetAtTime(targetSkidVol, this.ctx.currentTime, 0.1);
            },
            playCollect: function() {
                if (!this.ctx || !this.isSfxOn) return;
                const osc = this.ctx.createOscillator(); const gain = this.ctx.createGain();
                osc.type = 'sine'; osc.frequency.setValueAtTime(800, this.ctx.currentTime); osc.frequency.exponentialRampToValueAtTime(1200, this.ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime); gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain); gain.connect(this.ctx.destination); osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0xdcb183, 20, 200); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, highp: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; dirLight.shadow.mapSize.height = 4096; dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            createTerrain();
            createRings(); 
            loadModels();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { onKey(e, true); sfx.init(); sfx.playMusic(); });
            document.addEventListener('keyup', (e) => onKey(e, false));
            
            document.getElementById('camera-indicator').addEventListener('click', (e) => { e.stopPropagation(); switchCamera(); });
            document.getElementById('music-indicator').addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleMusic(); });
            document.getElementById('sfx-indicator').addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleSfx(); });

            controls.init(); 
            animate();
        }

        function updateProgress() {
            const total = Math.round((progressMoto + progressTree) / 2);
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('loading-text');
            if(bar) bar.style.width = total + "%";
            if(text && text.className !== 'error-msg') text.innerText = "DOWNLOADING... " + total + "%";
        }

        function checkLoading() { 
            if (assetsLoaded >= assetsTotal) { 
                sfx.init(); sfx.playMusic();
                setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 500); 
            } 
        }
        
        // ... (Standard Loaders from previous steps, but with MORE trees)
        function loadModels() {
            const loader = new FBXLoader();
            bikeGroup = new THREE.Group(); scene.add(bikeGroup); 
            
            // Visual holder for drift rotation
            bikeVisuals = new THREE.Group();
            bikeGroup.add(bikeVisuals);

            loader.load('fbx/moto.fbx', (object) => {
                object.scale.set(0.005, 0.005, 0.005); object.rotation.y = 0; 
                object.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                bikeVisuals.add(object);
                addExhaust();
                assetsLoaded++; checkLoading();
            }, (xhr) => { if (xhr.lengthComputable) { progressMoto = (xhr.loaded / xhr.total) * 100; updateProgress(); } else { progressMoto = 50; updateProgress(); } }, 
            (error) => { console.warn("Moto missing"); assetsLoaded++; checkLoading(); });

            loader.load('fbx/Tree.fbx', (object) => {
                // DOUBLED TREE COUNT
                const count = 80; const dummy = new THREE.Object3D(); const transforms = [];
                for(let i=0; i<count; i++) {
                    const x = (Math.random() - 0.5) * 200; const z = (Math.random() - 0.5) * 200;
                    if (Math.abs(x) < 20 && Math.abs(z) < 20) { i--; continue; } 
                    const y = getTerrainHeight(x, z);
                    dummy.position.set(x, y, z); dummy.rotation.set(0, Math.random() * Math.PI * 2, 0); dummy.scale.set(0.015, 0.015, 0.015); dummy.updateMatrix();
                    transforms.push(dummy.matrix.clone()); obstacles.push({ x: x, z: z, radius: 1.5 });
                }
                object.traverse((child) => {
                    if (child.isMesh) {
                        const instancedMesh = new THREE.InstancedMesh(child.geometry, child.material, count);
                        instancedMesh.castShadow = true; instancedMesh.receiveShadow = true;
                        for(let i=0; i<count; i++) instancedMesh.setMatrixAt(i, transforms[i]);
                        instancedMesh.instanceMatrix.needsUpdate = true; scene.add(instancedMesh);
                    }
                });
                assetsLoaded++; checkLoading();
            }, (xhr) => { if (xhr.lengthComputable) { progressTree = (xhr.loaded / xhr.total) * 100; updateProgress(); } else { progressTree = 50; updateProgress(); } }, 
            (err) => { console.warn("Tree missing"); assetsLoaded++; checkLoading(); });

            createProceduralPines(); createRocks();
            // Fences removed as requested
        }

        function createProceduralPines() {
            // DOUBLED PINE COUNT
            const count = 80; 
            const dummy = new THREE.Object3D();
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 1.5, 5); trunkGeo.translate(0, 0.75, 0);
            const leafGeo = BufferGeometryUtils.mergeGeometries([
                new THREE.ConeGeometry(1.2, 1.5, 5).translate(0, 2.0, 0),
                new THREE.ConeGeometry(0.9, 1.2, 5).translate(0, 2.8, 0),
                new THREE.ConeGeometry(0.6, 1.0, 5).translate(0, 3.5, 0)
            ]);
            const trunkMat = new THREE.MeshStandardMaterial({color: 0x3d2817});
            const leafMat = new THREE.MeshStandardMaterial({color: 0x1a472a});
            const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, count);
            const leafMesh = new THREE.InstancedMesh(leafGeo, leafMat, count);
            trunkMesh.castShadow = true; trunkMesh.receiveShadow = true; leafMesh.castShadow = true; leafMesh.receiveShadow = true;
            
            for(let i=0; i<count; i++) {
                const x = (Math.random() - 0.5) * 300; const z = (Math.random() - 0.5) * 300;
                if(Math.abs(x) < 20 && Math.abs(z) < 20) { i--; continue; }
                const y = getTerrainHeight(x, z); const s = 1.0 + Math.random() * 0.5;
                dummy.position.set(x, y, z); dummy.rotation.y = Math.random() * Math.PI; dummy.scale.set(s,s,s); dummy.updateMatrix();
                trunkMesh.setMatrixAt(i, dummy.matrix); leafMesh.setMatrixAt(i, dummy.matrix);
                obstacles.push({x:x, z:z, radius: 1.0});
            }
            scene.add(trunkMesh); scene.add(leafMesh);
        }

        function addExhaust() { const exhaustPoint = new THREE.Object3D(); exhaustPoint.position.set(0, 0.5, -1.2); exhaustPoint.name = "exhaust"; bikeVisuals.add(exhaustPoint); }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(400, 400, 400, 400); geometry.rotateX(-Math.PI / 2); 
            const positions = geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i]; const z = positions[i + 2];
                const y = (Math.sin(x * 0.03) * 5) + (Math.cos(z * 0.03) * 5) + (Math.sin(x * 0.1 + z * 0.1) * 1.5) + (Math.random() * 0.2);
                const dist = Math.sqrt(x*x + z*z); let bowl = 0; if(dist > 100) bowl = (dist - 100) * 0.15; positions[i + 1] = y + bowl;
            }
            geometry.computeVertexNormals();
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8B5A2B'; ctx.fillRect(0,0,1024,1024);
            for(let i=0; i<50000; i++) {
                const shade = Math.random(); if(shade > 0.6) ctx.fillStyle = '#A07040'; else if (shade > 0.3) ctx.fillStyle = '#5C4033'; else ctx.fillStyle = '#556B2F';
                const x = Math.random() * 1024; const y = Math.random() * 1024; const size = Math.random() * 3 + 1; ctx.fillRect(x, y, size, size);
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(10, 10);
            const material = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.9 });
            terrainMesh = new THREE.Mesh(geometry, material); terrainMesh.receiveShadow = true; scene.add(terrainMesh);
        }

        function getTerrainHeight(x, z) { const raycaster = new THREE.Raycaster(); raycaster.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0)); const intersects = raycaster.intersectObject(terrainMesh); return intersects.length > 0 ? intersects[0].point.y : 0; }
        
        function createRocks() {
             const rockGeo = new THREE.DodecahedronGeometry(1, 0); const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            for(let i=0; i< 30; i++) { const x = (Math.random() - 0.5) * 350; const z = (Math.random() - 0.5) * 350; const y = getTerrainHeight(x, z); const rock = new THREE.Mesh(rockGeo, rockMat); rock.position.set(x, y + 0.5, z); rock.scale.set(1 + Math.random(), 1 + Math.random(), 1 + Math.random()); rock.rotation.set(Math.random(), Math.random(), Math.random()); rock.castShadow = true; scene.add(rock); obstacles.push({ x: x, z: z, radius: 1.0 }); }
        }
        
        function createRings() {
            const geo = new THREE.TorusGeometry(0.8, 0.15, 8, 16);
            const mat = new THREE.MeshStandardMaterial({ color: 0xFFFF00, metalness: 0.1, roughness: 0.2, emissive: 0xFFFF00, emissiveIntensity: 0.8 });
            for(let i=0; i<20; i++) {
                const ring = new THREE.Mesh(geo, mat);
                const x = (Math.random() - 0.5) * 300; const z = (Math.random() - 0.5) * 300;
                const y = getTerrainHeight(x, z);
                ring.position.set(x, y + 0.2, z); ring.rotation.y = Math.random() * Math.PI; ring.castShadow = true;
                scene.add(ring); rings.push(ring);
            }
        }

        function createDust() {
            if(!bikeVisuals) return; 
            const exhaust = bikeVisuals.getObjectByName("exhaust"); 
            if (!exhaust) return; if (Math.abs(speed) < 0.1) return;
            const pos = new THREE.Vector3(); exhaust.getWorldPosition(pos); 
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2); 
            const mat = new THREE.MeshBasicMaterial({ color: 0x8b7e66, transparent: true, opacity: 0.4 }); 
            const p = new THREE.Mesh(geo, mat); 
            p.position.copy(pos); 
            p.position.x += (Math.random() - 0.5) * 0.3; 
            const gH = getTerrainHeight(pos.x, pos.z); 
            if(p.position.y < gH) p.position.y = gH + 0.2; 
            scene.add(p); 
            particles.push({ mesh: p, life: 1.0 });
        }
        
        function updateParticles() { 
            for (let i = particles.length - 1; i >= 0; i--) { 
                const p = particles[i]; p.life -= 0.02; p.mesh.position.y += 0.02; p.mesh.scale.multiplyScalar(1.05); p.mesh.material.opacity = p.life * 0.4; p.mesh.rotation.x += 0.1; 
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); } 
            } 
        }

        function onKey(e, pressed) { 
            const k = e.key.toLowerCase(); 
            if (k === 'w' || k === 'arrowup') keys.w = pressed; 
            if (k === 's' || k === 'arrowdown') keys.s = pressed; 
            if (k === 'a' || k === 'arrowleft') keys.a = pressed; 
            if (k === 'd' || k === 'arrowright') keys.d = pressed; 
            if (k === ' ') keys.brake = pressed; // Space is Handbrake
        }
        
        function switchCamera() { 
            activeCameraMode = (activeCameraMode + 1) % 2; 
            const ind = document.getElementById('camera-indicator'); 
            let nextMode = (activeCameraMode + 1) % 2;
            ind.innerText = nextMode === 0 ? "CAM: ANGLED VIEW" : "CAM: TOP VIEW";
        }
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkCollisions(newX, newZ) { const bikeRadius = 0.5; for(let obs of obstacles) { const dx = newX - obs.x; const dz = newZ - obs.z; const dist = Math.sqrt(dx*dx + dz*dz); if (dist < (bikeRadius + obs.radius)) return true; } return false; }
        function checkRings() { const playerPos = bikeGroup.position; for(let i = rings.length - 1; i >= 0; i--) { const ring = rings[i]; ring.rotation.y += 0.05; const dx = playerPos.x - ring.position.x; const dy = (playerPos.y + 0.5) - ring.position.y; const dz = playerPos.z - ring.position.z; const dist = Math.sqrt(dx*dx + dy*dy + dz*dz); if (dist < 2.0) { scene.remove(ring); rings.splice(i, 1); sfx.playCollect(); battery = Math.min(100, battery + RING_CHARGE); } } }
        function updateBattery() { if (Math.abs(speed) > 0.01) { battery -= BATTERY_DRAIN; if (battery < 0) battery = 0; } const bar = document.getElementById('battery-bar'); const txt = document.getElementById('battery-text'); bar.style.width = battery + "%"; txt.innerText = "BATTERY: " + Math.round(battery) + "%"; if (battery <= 0) speed *= 0.95; }

        function animate(time) {
            requestAnimationFrame(animate);
            if (time - lastTime >= 1000) { document.getElementById('fps').innerText = frameCount + " FPS"; frameCount = 0; lastTime = time; }
            frameCount++;

            let throttleInput = 0;
            if (keys.w) throttleInput += 1;
            if (keys.s) throttleInput -= 1;
            if (Math.abs(analogThrottle) > 0.1) throttleInput += analogThrottle;

            if (battery > 0 && throttleInput > 0) speed += ACCEL * throttleInput;
            if (throttleInput < 0) speed += ACCEL * throttleInput; 
            
            speed *= FRICTION;
            
            let turnInput = 0; if (keys.a) turnInput += 1; if (keys.d) turnInput -= 1; turnInput += analogSteering; 
            
            // DRIFT LOGIC
            let isDrifting = false;
            if (keys.brake && Math.abs(speed) > 0.3 && Math.abs(turnInput) > 0.3) {
                isDrifting = true;
                // Lose friction but maintain momentum
                speed *= DRIFT_FRICTION; 
                // Increase turn rate (oversteer)
                bikeGroup.rotation.y += turnInput * (TURN_SPEED * 1.8);
            } else {
                // Standard turn
                if (Math.abs(speed) > 0.05) bikeGroup.rotation.y += turnInput * TURN_SPEED;
            }

            if (bikeGroup) {
                // CALCULATE MOVEMENT
                // If drifting, we don't just move where we face. We slide.
                const forwardDir = new THREE.Vector3(0,0,1).applyAxisAngle(new THREE.Vector3(0,1,0), bikeGroup.rotation.y);
                
                if(isDrifting) {
                    // Create a slide vector that pushes slightly opposite to the turn (centrifugal force feel)
                    // Simplified: Just move in the direction of momentum (previous velocity would be best, but simple forward override works)
                    // Actually, for arcade feel: Move roughly forward but slide sideways
                    const slideForce = speed * 0.2;
                    // We drift OUT of the turn. If turning LEFT (turnInput > 0), we slide RIGHT (local -X).
                    bikeGroup.translateX(-turnInput * slideForce);
                    
                    // Visual Tilt
                    if(bikeVisuals) bikeVisuals.rotation.y = -turnInput * 0.5; // Oversteer visual
                    
                    if(frameCount % 3 === 0) createDust();
                } else {
                    if(bikeVisuals) bikeVisuals.rotation.y *= 0.9; // Reset visual
                }
                
                // Apply Velocity
                const moveDist = speed;
                const dx = Math.sin(bikeGroup.rotation.y) * moveDist;
                const dz = Math.cos(bikeGroup.rotation.y) * moveDist;
                const nextX = bikeGroup.position.x + dx;
                const nextZ = bikeGroup.position.z + dz;

                if (checkCollisions(nextX, nextZ)) { 
                    speed = -speed * 0.5; sfx.playLand(1.0); 
                } else { 
                    bikeGroup.position.x += dx;
                    bikeGroup.position.z += dz;
                }

                if (bikeGroup.position.x > MAP_LIMIT) { bikeGroup.position.x = MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.x < -MAP_LIMIT) { bikeGroup.position.x = -MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.z > MAP_LIMIT) { bikeGroup.position.z = MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.z < -MAP_LIMIT) { bikeGroup.position.z = -MAP_LIMIT; speed = 0; }

                sfx.updateEngine(Math.abs(speed), isDrifting);
                checkRings();
                updateBattery();

                const groundH = getTerrainHeight(bikeGroup.position.x, bikeGroup.position.z);
                
                // FORCE GROUND CLAMP (No jumping)
                bikeGroup.position.y = groundH;

                // Align to terrain normal
                const aheadX = bikeGroup.position.x + Math.sin(bikeGroup.rotation.y);
                const aheadZ = bikeGroup.position.z + Math.cos(bikeGroup.rotation.y);
                const aheadH = getTerrainHeight(aheadX, aheadZ);
                const pitch = Math.atan2(aheadH - groundH, 1.0);
                bikeGroup.rotation.x = THREE.MathUtils.lerp(bikeGroup.rotation.x, -pitch, 0.2);
                
                // Roll
                const targetRoll = turnInput * 0.3; 
                bikeGroup.rotation.z = THREE.MathUtils.lerp(bikeGroup.rotation.z, targetRoll, 0.1);

                // Camera Follow
                const targetPos = bikeGroup.position.clone();
                let camOffset = new THREE.Vector3();
                let lookOffset = new THREE.Vector3(0, 2, 0);

                switch(activeCameraMode) {
                    case 0: // Chase
                        camOffset.set(0, 4, -8);
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                        break;
                    case 1: // Top
                        camOffset.set(0, 25, -2); // High up
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y); // Rotate with bike
                        break;
                }

                const camPos = targetPos.clone().add(camOffset);
                // Cam collision
                const camGroundH = getTerrainHeight(camPos.x, camPos.z);
                if (camPos.y < camGroundH + 1.0) camPos.y = camGroundH + 1.0;

                camera.position.lerp(camPos, 0.1);
                camera.lookAt(targetPos.clone().add(lookOffset));
            }

            createDust(); updateParticles();
            document.getElementById('speed').innerText = Math.abs(Math.round(speed * 100)) + " KM/H";
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


