<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Tesla Madness 1998 - Cybertruck Edition</title>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        #ui-layer {
            position: absolute;
            top: max(20px, env(safe-area-inset-top)); 
            left: max(20px, env(safe-area-inset-left));
            color: #ffcc00;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            z-index: 10;
        }
        
        h1 { margin: 0; font-size: clamp(16px, 4vw, 24px); letter-spacing: 2px; text-transform: uppercase; font-weight: bold; }
        p { margin: 5px 0; font-size: clamp(10px, 3vw, 14px); color: #fff; }
        .accent { color: #00ff00; }
        .blink { animation: blinker 1.5s linear infinite; color: #ff00ff; }
        @keyframes blinker { 50% { opacity: 0; } }
        
        .hud-stats {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            text-align: right;
            color: #fff;
            z-index: 10;
            pointer-events: none;
            font-size: clamp(12px, 3.5vw, 16px);
        }

        #camera-indicator {
            position: absolute;
            top: max(60px, calc(env(safe-area-inset-top) + 40px));
            right: max(20px, env(safe-area-inset-right));
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffcc00;
            padding: 5px 10px;
            color: #ffcc00;
            font-weight: bold;
            text-transform: uppercase;
            font-size: clamp(10px, 2.5vw, 12px);
            pointer-events: auto; 
            cursor: pointer;
            z-index: 20;
            border-radius: 4px;
        }

        .touch-controls {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 0;
            width: 100%;
            height: auto;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            box-sizing: border-box;
            align-items: flex-end;
        }

        .d-pad, .actions {
            pointer-events: auto;
            display: flex;
            gap: 15px;
            align-items: flex-end;
        }

        .btn {
            background: rgba(255, 255, 255, 0.15);
            border: 2px solid rgba(255, 204, 0, 0.5);
            color: #ffcc00;
            border-radius: 50%;
            width: clamp(50px, 15vw, 70px);
            height: clamp(50px, 15vw, 70px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: clamp(18px, 5vw, 24px);
            font-weight: bold;
            touch-action: manipulation;
            user-select: none;
            transition: background 0.1s, transform 0.05s;
            backdrop-filter: blur(4px);
            -webkit-backdrop-filter: blur(4px);
        }

        .btn:active, .btn.active {
            background: rgba(255, 204, 0, 0.6);
            color: #000;
            transform: scale(0.95);
        }

        .btn-rect { width: clamp(60px, 16vw, 80px); height: clamp(50px, 15vw, 70px); border-radius: 12px; font-size: clamp(12px, 3.5vw, 16px); }
        .btn-large { width: clamp(70px, 18vw, 90px); height: clamp(70px, 18vw, 90px); font-size: clamp(12px, 3.5vw, 16px); border-color: #fff; background: rgba(255, 50, 50, 0.3); color: #fff; }

        @media (max-width: 600px) {
            .touch-controls { flex-direction: row; align-items: flex-end; }
            .d-pad, .actions { gap: 8px; }
            .btn { border-width: 1.5px; }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <h1>TESLA MADNESS '98</h1>
        <p>VEHICLE: <span class="accent">CYBERTRUCK</span> | SFX: <span class="blink">READY</span></p>
        <p class="desktop-hint">KEYBOARD: WASD | SPACE</p>
        <p class="mobile-hint">TOUCH: Controls Active</p>
        <p style="color:#aaa; font-size:10px; margin-top:5px;">* TAP SCREEN TO START AUDIO *</p>
    </div>

    <div id="camera-indicator">CAM: 3RD PERSON</div>

    <div class="hud-stats">
        <div id="speed">0 KM/H</div>
        <div id="fps">60 FPS</div>
    </div>

    <div class="touch-controls">
        <div class="d-pad">
            <div class="btn" id="btn-left">◄</div>
            <div class="btn" id="btn-right">►</div>
        </div>
        <div class="actions">
            <div class="btn btn-rect" id="btn-brake">BRAKE</div>
            <div class="btn btn-rect" id="btn-gas">GAS</div>
            <div class="btn btn-large" id="btn-jump">JUMP</div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer;
        let bikeGroup, terrainMesh;
        let speed = 0;
        let velocity = new THREE.Vector3();
        let verticalVelocity = 0; 
        let particles = [];
        let frameCount = 0;
        let lastTime = 0;
        let billboardTrees = [];
        let isAirborne = false;
        
        const MAX_SPEED = 1.2;
        const ACCEL = 0.02;
        const FRICTION = 0.98;
        const TURN_SPEED = 0.04;
        const GRAVITY = 0.025; 
        const JUMP_FORCE = 0.8; 
        const MAP_LIMIT = 195; 
        
        const keys = { w: false, a: false, s: false, d: false, space: false };
        let activeCameraMode = 1; 

        // --- AUDIO ENGINE ---
        const sfx = {
            ctx: null, engineOsc: null, engineGain: null, filter: null, noiseBuffer: null,
            init: function() {
                if (this.ctx) return;
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                const bufferSize = this.ctx.sampleRate * 2; 
                this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = this.noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;

                this.engineOsc = this.ctx.createOscillator();
                this.engineOsc.type = 'sawtooth';
                this.engineOsc.frequency.value = 60;
                this.engineGain = this.ctx.createGain();
                this.engineGain.gain.value = 0;
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 400;

                this.engineOsc.connect(this.filter);
                this.filter.connect(this.engineGain);
                this.engineGain.connect(this.ctx.destination);
                this.engineOsc.start();
            },
            updateEngine: function(speedPercent) {
                if (!this.ctx) return;
                // Electric hum sound profile
                const pitch = 80 + (speedPercent * 400); 
                this.engineOsc.frequency.setTargetAtTime(pitch, this.ctx.currentTime, 0.1);
                
                const vol = 0.05 + (speedPercent * 0.15); 
                this.engineGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);

                const cutoff = 300 + (speedPercent * 2000);
                this.filter.frequency.setTargetAtTime(cutoff, this.ctx.currentTime, 0.1);
            },
            playLand: function(intensity) {
                if (!this.ctx) return;
                const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(Math.min(intensity * 0.5, 0.5), this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';
                filter.frequency.setValueAtTime(600, this.ctx.currentTime); filter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.2);
                src.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                src.start(); src.stop(this.ctx.currentTime + 0.3);
            },
            playJump: function() {
                 if (!this.ctx) return;
                const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
                const filter = this.ctx.createBiquadFilter(); filter.type = 'highpass';
                filter.frequency.setValueAtTime(400, this.ctx.currentTime); filter.frequency.linearRampToValueAtTime(1000, this.ctx.currentTime + 0.2);
                src.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                src.start();
            }
        };

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB); 
            scene.fog = new THREE.Fog(0xdcb183, 20, 200); 

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ antialias: true, highp: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(50, 100, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048; 
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            createTerrain();
            createCybertruck();
            createEnhancedTrees();
            createBillboardTrees();
            createRocks();
            createFences();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', (e) => { onKey(e, true); sfx.init(); });
            document.addEventListener('keyup', (e) => onKey(e, false));
            document.addEventListener('mousedown', () => sfx.init()); 
            document.addEventListener('touchstart', () => sfx.init()); 
            
            const camInd = document.getElementById('camera-indicator');
            camInd.addEventListener('click', (e) => { e.stopPropagation(); switchCamera(); });

            setupTouchControls();
            
            animate();
        }

        function createCybertruck() {
            bikeGroup = new THREE.Group();
            
            // Materials
            const metalMat = new THREE.MeshStandardMaterial({ 
                color: 0xcccccc, 
                roughness: 0.2, 
                metalness: 0.9 
            });
            const glassMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.1, 
                metalness: 0.5 
            });
            const tireMat = new THREE.MeshStandardMaterial({ 
                color: 0x111111, 
                roughness: 0.9 
            });
            const lightMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const tailMat = new THREE.MeshBasicMaterial({ color: 0xff0000 });

            // 1. Chassis Body (Extruded Shape for Profile)
            const length = 1.8;
            const width = 0.8;
            const shape = new THREE.Shape();
            
            // Draw profile from side view
            shape.moveTo(-0.9, 0); // Bottom rear
            shape.lineTo(0.9, 0);  // Bottom front
            shape.lineTo(0.9, 0.4); // Front bumper top
            shape.lineTo(0.4, 0.45); // Hood start
            shape.lineTo(0.0, 0.9);  // Roof Peak
            shape.lineTo(-0.9, 0.6); // Bed top
            shape.lineTo(-0.9, 0);   // Close

            const extrudeSettings = {
                steps: 1,
                depth: width,
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelSegments: 1
            };

            const chassisGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            chassisGeo.center(); // Center the geometry
            const chassis = new THREE.Mesh(chassisGeo, metalMat);
            chassis.position.y = 0.6;
            chassis.castShadow = true;
            chassis.receiveShadow = true;
            bikeGroup.add(chassis);

            // 2. Windows (Simple Planes slightly offset)
            const winGeo = new THREE.PlaneGeometry(0.7, 0.3);
            const winL = new THREE.Mesh(winGeo, glassMat);
            winL.position.set(0.1, 0.85, 0.41);
            winL.rotation.y = 0; // Side
            // Actually simpler to just use black boxes clipping in
            const glassBlock = new THREE.BoxGeometry(1.2, 0.3, 0.82);
            const glass = new THREE.Mesh(glassBlock, glassMat);
            glass.position.set(0, 0.75, 0);
            // This is a hack, but works for low poly "tinted windows" look
            // bikeGroup.add(glass); 

            // 3. Wheels (Chunky Cylinders)
            const wheelGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.3, 16);
            wheelGeo.rotateZ(Math.PI / 2);
            
            const wheelPos = [
                { x: 0.6, z: 0.35 }, { x: 0.6, z: -0.35 },
                { x: -0.6, z: 0.35 }, { x: -0.6, z: -0.35 }
            ];

            wheelPos.forEach(pos => {
                const w = new THREE.Mesh(wheelGeo, tireMat);
                w.position.set(pos.x, 0.25, pos.z);
                w.castShadow = true;
                bikeGroup.add(w);
                
                // Hubcap
                const cap = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.32, 6), metalMat);
                cap.rotation.z = Math.PI/2;
                cap.position.copy(w.position);
                bikeGroup.add(cap);
            });

            // 4. Lights (Lightbar)
            const headLightGeo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
            const headLight = new THREE.Mesh(headLightGeo, lightMat);
            headLight.position.set(0.88, 0.65, 0);
            bikeGroup.add(headLight);

            const tailLightGeo = new THREE.BoxGeometry(0.05, 0.05, 0.8);
            const tailLight = new THREE.Mesh(tailLightGeo, tailMat);
            tailLight.position.set(-0.88, 0.65, 0);
            bikeGroup.add(tailLight);

            // Exhaust (Particle emitter point)
            const exhaustPoint = new THREE.Object3D();
            exhaustPoint.position.set(-0.9, 0.2, 0);
            exhaustPoint.name = "exhaust";
            bikeGroup.add(exhaustPoint);

            scene.add(bikeGroup);
        }

        function createEnhancedTrees() {
            // Create a merged geometry for a single tree
            // Trunk
            const trunkGeo = new THREE.CylinderGeometry(0.2, 0.4, 1.5, 6);
            trunkGeo.translate(0, 0.75, 0);
            
            // Foliage Layers (Stacked Cones)
            const layer1 = new THREE.ConeGeometry(1.2, 1.5, 6);
            layer1.translate(0, 2.0, 0);
            
            const layer2 = new THREE.ConeGeometry(0.9, 1.2, 6);
            layer2.translate(0, 2.8, 0);
            
            const layer3 = new THREE.ConeGeometry(0.6, 1.0, 6);
            layer3.translate(0, 3.5, 0);

            // Merge geometries? 
            // For InstancedMesh with multi-materials, it's tricky. 
            // Easier: 2 InstancedMeshes. One for trunks, one for leaves.
            
            const count = 80;
            const dummy = new THREE.Object3D();
            const transforms = []; // Store matrices

            // Calculate positions
            for(let i=0; i<count; i++) {
                const x = (Math.random() - 0.5) * 300;
                const z = (Math.random() - 0.5) * 300;
                if(Math.abs(x) < 20 && Math.abs(z) < 20) { i--; continue; }
                
                const y = getTerrainHeight(x, z);
                const s = 1.0 + Math.random() * 0.5;
                
                dummy.position.set(x, y, z);
                dummy.scale.set(s, s, s);
                dummy.rotation.y = Math.random() * Math.PI;
                dummy.updateMatrix();
                transforms.push(dummy.matrix.clone());
            }

            // 1. Trunks InstancedMesh
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 1.0 });
            const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, count);
            trunkMesh.castShadow = true;
            trunkMesh.receiveShadow = true;
            
            // 2. Foliage InstancedMesh (Merge cones first for single draw call per tree part)
            const foliageGeo = BufferGeometryUtils.mergeGeometries([layer1, layer2, layer3]);
            const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2d5a27, roughness: 0.8 });
            const foliageMesh = new THREE.InstancedMesh(foliageGeo, foliageMat, count);
            foliageMesh.castShadow = true;
            foliageMesh.receiveShadow = true;

            // Apply matrices
            for(let i=0; i<count; i++) {
                trunkMesh.setMatrixAt(i, transforms[i]);
                foliageMesh.setMatrixAt(i, transforms[i]);
            }

            scene.add(trunkMesh);
            scene.add(foliageMesh);
        }

        function setupTouchControls() {
            const bindTouch = (id, key) => {
                const el = document.getElementById(id);
                const start = (e) => { e.preventDefault(); keys[key] = true; el.classList.add('active'); sfx.init(); };
                const end = (e) => { e.preventDefault(); keys[key] = false; el.classList.remove('active'); };
                el.addEventListener('touchstart', start, { passive: false });
                el.addEventListener('touchend', end, { passive: false });
                el.addEventListener('mousedown', start);
                el.addEventListener('mouseup', end);
                el.addEventListener('mouseleave', end);
            };
            bindTouch('btn-left', 'a');
            bindTouch('btn-right', 'd');
            bindTouch('btn-gas', 'w');
            bindTouch('btn-brake', 's');
            bindTouch('btn-jump', 'space');
        }

        function createTerrain() {
            const geometry = new THREE.PlaneGeometry(400, 400, 150, 150);
            geometry.rotateX(-Math.PI / 2);
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i];
                const z = positions[i + 2];
                // Smoother rolling hills
                const y = (Math.sin(x * 0.03) * 5) + (Math.cos(z * 0.03) * 5) + (Math.sin(x * 0.1 + z * 0.1) * 2);
                
                // Edge containment bowl
                const dist = Math.sqrt(x*x + z*z);
                let bowl = 0;
                if(dist > 100) bowl = (dist - 100) * 0.15;
                
                positions[i + 1] = y + bowl;
            }
            geometry.computeVertexNormals();

            // Simple Vertex Colors or Texture
            const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#C2B280'; ctx.fillRect(0,0,512,512); // Sand
            // Noise
            for(let i=0; i<10000; i++) {
                ctx.fillStyle = Math.random() > 0.5 ? '#dcb183' : '#a08060';
                ctx.fillRect(Math.random()*512, Math.random()*512, 2, 2);
            }
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; tex.repeat.set(20, 20);

            const material = new THREE.MeshStandardMaterial({ map: tex, roughness: 1.0 });
            terrainMesh = new THREE.Mesh(geometry, material);
            terrainMesh.receiveShadow = true;
            scene.add(terrainMesh);
        }

        function getTerrainHeight(x, z) {
            const raycaster = new THREE.Raycaster();
            raycaster.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
            const intersects = raycaster.intersectObject(terrainMesh);
            return intersects.length > 0 ? intersects[0].point.y : 0;
        }

        function createBillboardTrees() {
            // Distant trees
            const billboardGeo = new THREE.PlaneGeometry(8, 12);
            const billboardMat = new THREE.MeshBasicMaterial({ color: 0x1a5c1a, side: THREE.DoubleSide, transparent:true, opacity:0.8 });
            for(let i=0; i<50; i++) {
                const angle = Math.random() * Math.PI * 2; const rad = 150 + Math.random() * 50;
                const x = Math.cos(angle) * rad; const z = Math.sin(angle) * rad; const y = getTerrainHeight(x, z) + 6;
                const bb = new THREE.Mesh(billboardGeo, billboardMat); bb.position.set(x,y,z); scene.add(bb); billboardTrees.push(bb);
            }
        }

        function createRocks() {
             const rockGeo = new THREE.DodecahedronGeometry(1, 0); const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            for(let i=0; i< 30; i++) {
                const x = (Math.random() - 0.5) * 350; const z = (Math.random() - 0.5) * 350; const y = getTerrainHeight(x, z);
                const rock = new THREE.Mesh(rockGeo, rockMat); rock.position.set(x, y + 0.5, z); rock.scale.set(1 + Math.random(), 1 + Math.random(), 1 + Math.random()); rock.rotation.set(Math.random(), Math.random(), Math.random()); rock.castShadow = true; scene.add(rock);
            }
        }

        function createFences() {
            const postGeo = new THREE.CylinderGeometry(0.1, 0.1, 1.5, 6); const postMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
            const railGeo = new THREE.BoxGeometry(0.05, 0.05, 5);
            for(let i=0; i<10; i++) {
                const x = -30 + (i * 5); const z = 20; const y = getTerrainHeight(x, z);
                const post = new THREE.Mesh(postGeo, postMat); post.position.set(x, y+0.75, z); post.castShadow = true; scene.add(post);
                if (i < 9) {
                    const rail = new THREE.Mesh(railGeo, postMat); rail.position.set(x + 2.5, y + 1.2, z); scene.add(rail);
                    const rail2 = new THREE.Mesh(railGeo, postMat); rail2.position.set(x + 2.5, y + 0.8, z); scene.add(rail2);
                }
            }
        }

        function createDust() {
            if(!bikeGroup) return;
            const exhaust = bikeGroup.getObjectByName("exhaust");
            if (!exhaust) return; if (Math.abs(speed) < 0.1) return;
            const pos = new THREE.Vector3(); exhaust.getWorldPosition(pos);
            const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2); const mat = new THREE.MeshBasicMaterial({ color: 0x8b7e66, transparent: true, opacity: 0.4 });
            const p = new THREE.Mesh(geo, mat); p.position.copy(pos); p.position.x += (Math.random() - 0.5) * 0.3;
            const gH = getTerrainHeight(pos.x, pos.z); if(p.position.y < gH) p.position.y = gH + 0.2;
            scene.add(p); particles.push({ mesh: p, life: 1.0 });
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i]; p.life -= 0.02; p.mesh.position.y += 0.02; p.mesh.scale.multiplyScalar(1.05); p.mesh.material.opacity = p.life * 0.4; p.mesh.rotation.x += 0.1;
                if (p.life <= 0) { scene.remove(p.mesh); particles.splice(i, 1); }
            }
        }

        function onKey(e, pressed) {
            const k = e.key.toLowerCase();
            if (k === 'w' || k === 'arrowup') keys.w = pressed;
            if (k === 's' || k === 'arrowdown') keys.s = pressed;
            if (k === 'a' || k === 'arrowleft') keys.a = pressed;
            if (k === 'd' || k === 'arrowright') keys.d = pressed;
            if (k === ' ') keys.space = pressed;
        }

        function switchCamera() {
            activeCameraMode = activeCameraMode === 0 ? 1 : 0;
            const ind = document.getElementById('camera-indicator');
            ind.innerText = activeCameraMode === 0 ? "CAM: TOP DOWN" : "CAM: 3RD PERSON";
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate(time) {
            requestAnimationFrame(animate);

            if (time - lastTime >= 1000) { document.getElementById('fps').innerText = frameCount + " FPS"; frameCount = 0; lastTime = time; }
            frameCount++;

            if (keys.w) speed += ACCEL;
            if (keys.s) speed -= ACCEL;
            speed *= FRICTION;
            
            if (bikeGroup && Math.abs(speed) > 0.05) {
                if (keys.a) bikeGroup.rotation.y += TURN_SPEED;
                if (keys.d) bikeGroup.rotation.y -= TURN_SPEED;
            }

            if (bikeGroup) {
                velocity.set(0, 0, speed);
                velocity.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                bikeGroup.position.add(velocity);

                if (bikeGroup.position.x > MAP_LIMIT) { bikeGroup.position.x = MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.x < -MAP_LIMIT) { bikeGroup.position.x = -MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.z > MAP_LIMIT) { bikeGroup.position.z = MAP_LIMIT; speed = 0; }
                if (bikeGroup.position.z < -MAP_LIMIT) { bikeGroup.position.z = -MAP_LIMIT; speed = 0; }

                sfx.updateEngine(Math.abs(speed));

                const groundH = getTerrainHeight(bikeGroup.position.x, bikeGroup.position.z);
                verticalVelocity -= GRAVITY;
                bikeGroup.position.y += verticalVelocity;

                if (bikeGroup.position.y > groundH + 0.2) isAirborne = true;

                if (bikeGroup.position.y < groundH) {
                    bikeGroup.position.y = groundH;
                    if (isAirborne) { sfx.playLand(Math.abs(verticalVelocity) * 2); isAirborne = false; }
                    verticalVelocity = 0;
                    if (keys.space) { verticalVelocity = JUMP_FORCE; sfx.playJump(); isAirborne = true; }
                }

                const aheadV = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                const nextX = bikeGroup.position.x + aheadV.x;
                const nextZ = bikeGroup.position.z + aheadV.z;
                const nextH = getTerrainHeight(nextX, nextZ);
                const angle = Math.atan2(nextH - groundH, 1.0);
                bikeGroup.rotation.x = THREE.MathUtils.lerp(bikeGroup.rotation.x, -angle, 0.1);
                
                if (keys.a) bikeGroup.rotation.z = Math.min(bikeGroup.rotation.z + 0.05, 0.3);
                else if (keys.d) bikeGroup.rotation.z = Math.max(bikeGroup.rotation.z - 0.05, -0.3);
                else bikeGroup.rotation.z *= 0.9; 

                const targetPos = bikeGroup.position.clone();
                if (activeCameraMode === 1) {
                    const offset = new THREE.Vector3(0, 3, -6); offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                    const camPos = targetPos.clone().add(offset);
                    const camGroundH = getTerrainHeight(camPos.x, camPos.z);
                    if (camPos.y < camGroundH + 1.0) camPos.y = camGroundH + 1.0;
                    camera.position.lerp(camPos, 0.1);
                    camera.lookAt(targetPos.x, targetPos.y + 1, targetPos.z);
                } else {
                    camera.position.set(targetPos.x, targetPos.y + 25, targetPos.z + 5);
                    camera.lookAt(targetPos);
                }
            }

            billboardTrees.forEach(bb => bb.lookAt(camera.position));
            createDust(); updateParticles();
            document.getElementById('speed').innerText = Math.abs(Math.round(speed * 100)) + " KM/H";
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>


