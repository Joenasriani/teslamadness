<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Cybertruck Madness 1998 - Physics Update</title>
    
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; 
            -webkit-user-select: none; 
            user-select: none; 
        }
        #canvas-container { width: 100vw; height: 100vh; display: block; }
        
        /* LEFT HEADER UI */
        #ui-layer {
            position: absolute;
            top: max(20px, env(safe-area-inset-top)); 
            left: max(20px, env(safe-area-inset-left));
            color: #ffcc00;
            text-shadow: 2px 2px 0px #000;
            pointer-events: none;
            z-index: 10;
            width: auto;
            max-width: 50%;
            display: flex;
            flex-direction: column;
            gap: 15px; 
        }
        
        h1 { 
            margin: 0; 
            font-size: clamp(14px, 4vw, 24px); 
            letter-spacing: 1px; 
            text-transform: uppercase; 
            font-weight: bold; 
            white-space: nowrap; 
            line-height: 1.2;
        }
        p { margin: 0; font-size: clamp(9px, 2.5vw, 14px); color: #fff; } 
        .accent { color: #00ff00; }

        /* BATTERY BAR */
        .battery-container {
            margin: 0; 
            width: 100%;
            height: 12px;
            background: rgba(0,0,0,0.5);
            border: 1px solid #fff;
            position: relative;
        }
        #battery-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff0000, #ffff00, #00ff00);
            transition: width 0.2s;
        }
        #battery-text {
            position: absolute;
            top: -18px; 
            right: 0;
            font-size: clamp(9px, 2.5vw, 12px);
            color: #fff;
            text-shadow: 1px 1px 0 #000;
        }
        
        /* RIGHT HEADER UI */
        .hud-stats {
            position: absolute;
            top: max(20px, env(safe-area-inset-top));
            right: max(20px, env(safe-area-inset-right));
            text-align: right;
            color: #fff;
            z-index: 10;
            pointer-events: none;
            font-size: clamp(12px, 3.5vw, 16px);
            max-width: 40%;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 8px;
        }

        /* HUD BUTTONS */
        .hud-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid #ffcc00;
            padding: 5px 8px;
            color: #ffcc00;
            font-weight: bold;
            text-transform: uppercase;
            font-size: clamp(9px, 2.5vw, 12px);
            pointer-events: auto; 
            cursor: pointer;
            border-radius: 4px;
            white-space: nowrap;
            text-shadow: 1px 1px 0 #000;
            transition: background 0.1s, opacity 0.2s;
        }
        
        .hud-btn:active { background: rgba(255, 204, 0, 0.3); }

        .hud-btn.off {
            border-color: #555;
            color: #888;
            opacity: 0.7;
        }

        /* COMPASS NAV */
        #compass-container {
            position: absolute;
            top: max(80px, env(safe-area-inset-top)); 
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 40px;
            background: rgba(0,0,0,0.6);
            border: 2px solid #ffcc00;
            border-radius: 50%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #compass-arrow {
            width: 0; 
            height: 0; 
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 20px solid #ffcc00;
            transform-origin: bottom center;
        }
        #compass-label {
            position: absolute;
            bottom: -15px;
            width: 100px;
            text-align: center;
            font-size: 10px;
            color: #ffcc00;
            text-shadow: 1px 1px 0 #000;
        }

        /* EXPANDED MAP OVERLAY */
        #map-overlay {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 80vmin;
            height: 80vmin;
            background: rgba(0, 20, 0, 0.95);
            border: 2px solid #ffcc00;
            z-index: 150;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        #big-map-canvas {
            width: 95%;
            height: 95%;
            background: #000;
            border: 1px solid #333;
        }
        #map-toggle-btn {
            margin-top: 10px;
        }

        /* LOADING SCREEN */
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: clamp(280px, 60vw, 500px);
            background: black;
            padding: 20px;
            border: 2px solid #ffcc00;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            text-align: center;
            box-shadow: 0 0 20px rgba(255, 204, 0, 0.2);
        }
        .loading-title { color: white; font-size: clamp(16px, 4vw, 20px); margin-bottom: 15px; text-transform: uppercase; letter-spacing: 1px; }
        .progress-track { width: 100%; height: 20px; background: #222; border: 1px solid #555; margin-bottom: 10px; position: relative; }
        #progress-bar { width: 0%; height: 100%; background: #ffcc00; transition: width 0.2s; }
        #loading-text { color: #aaa; font-size: 12px; }
        .error-msg { color: #ff3333 !important; }

        /* --- MOBILE CONTROLS --- */
        .touch-controls {
            position: absolute;
            bottom: max(20px, env(safe-area-inset-bottom));
            left: 0;
            width: 100%;
            height: auto;
            pointer-events: none;
            z-index: 50;
            display: flex;
            justify-content: space-between;
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            box-sizing: border-box;
            align-items: flex-end;
        }

        /* SHARED ZONE STYLES */
        .control-zone {
            width: 45%; height: 250px;
            pointer-events: auto;
            touch-action: none;
            position: relative;
        }

        /* TEXT HINTS */
        .zone-hint {
            position: absolute;
            bottom: 20px;
            color: rgba(255,255,255,0.3);
            font-size: 12px;
            pointer-events: none;
            font-weight: bold;
            text-transform: uppercase;
        }
        .hint-left { left: 0; }
        .hint-right { right: 0; text-align: right; }

        /* DYNAMIC VISUAL ELEMENTS */
        .touch-feedback-base {
            position: absolute;
            width: 100px; height: 100px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 204, 0, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
            pointer-events: none;
        }
        
        .touch-feedback-knob {
            position: absolute;
            width: 50px; height: 50px;
            background: rgba(255, 204, 0, 0.8);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: 50%; top: 50%;
            box-shadow: 0 0 15px rgba(255, 204, 0, 0.6);
        }

        /* RED BRAKE BUTTON VISUAL */
        #brake-visual .touch-feedback-knob {
            width: 90px; height: 90px;
            background: rgba(255, 50, 50, 0.6);
            border: 2px solid #ff3333;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
        }
        
        #brake-visual .touch-feedback-knob::after {
            content: "BRAKE";
        }

        /* END GAME MESSAGE */
        #win-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            border: 4px solid #00ff00;
            padding: 40px;
            text-align: center;
            color: #fff;
            display: none;
            z-index: 200;
        }

        /* --- MOBILE OVERLAP FIX --- */
        @media screen and (max-width: 768px) {
            #ui-layer {
                top: max(10px, env(safe-area-inset-top));
                left: max(10px, env(safe-area-inset-left));
                max-width: 55%;
                gap: 6px;
            }
            
            .hud-stats {
                top: max(10px, env(safe-area-inset-top));
                right: max(10px, env(safe-area-inset-right));
                max-width: 40%;
                gap: 6px;
            }

            h1 {
                font-size: 16px; /* Smaller title to prevent overlap */
                white-space: normal; /* Allow wrap if necessary */
                line-height: 1;
            }

            p {
                font-size: 10px;
            }

            .battery-container {
                height: 8px;
            }
            
            #battery-text {
                top: -14px;
                font-size: 9px;
            }

            .hud-btn {
                padding: 4px 6px;
                font-size: 9px;
                margin-bottom: 2px;
            }

            /* Push compass down on mobile so it doesn't hit UI */
            #compass-container {
                top: max(130px, env(safe-area-inset-top));
            }
        }
    </style>
</head>
<body>

    <div id="loading">
        <div class="loading-title">CHARGING BATTERIES...</div>
        <div class="progress-track">
            <div id="progress-bar"></div>
        </div>
        <div id="loading-text">LOADING ASSETS...</div>
    </div>

    <div id="win-msg">
        <h1 style="color:#00ff00; font-size:40px;">MISSION COMPLETE</h1>
        <p>YOU REACHED THE EXTRACTION POINT</p>
        <div class="hud-btn" onclick="location.reload()" style="margin-top:20px; display:inline-block;">REPLAY</div>
    </div>

    <!-- LEFT HEADER -->
    <div id="ui-layer">
        <h1>CYBERTRUCK MADNESS '98</h1>
        <div class="battery-container">
            <div id="battery-bar"></div>
            <div id="battery-text">BATTERY: 100%</div>
        </div>
        <p id="rings-status">Collect <span style="color: #ffcc00;">Gold Rings</span> to Recharge</p>
    </div>

    <!-- RIGHT HEADER -->
    <div class="hud-stats">
        <div id="speed">0 KM/H</div>
        <div id="fps">60 FPS</div>
        
        <!-- BUTTONS -->
        <div id="map-toggle-btn" class="hud-btn">MAP</div>
        <div id="camera-indicator" class="hud-btn">CAM: FAR CHASE</div>
        <div id="music-indicator" class="hud-btn">MUSIC: ON</div>
        <div id="sfx-indicator" class="hud-btn">SFX: ON</div>
        
        <div id="objective-text">RINGS: 0 / 500</div>
    </div>

    <!-- COMPASS NAV -->
    <div id="compass-container">
        <div id="compass-arrow"></div>
        <div id="compass-label">NEAREST RING</div>
    </div>

    <!-- EXPANDED MAP OVERLAY -->
    <div id="map-overlay">
        <canvas id="big-map-canvas" width="600" height="600"></canvas>
        <div class="hud-btn" style="margin-top:10px; cursor:pointer;" id="close-map-btn">CLOSE MAP</div>
    </div>

    <!-- CONTROLS -->
    <div class="touch-controls">
        <!-- LEFT: JOYSTICK -->
        <div id="joystick-zone" class="control-zone">
            <div class="zone-hint hint-left">MOVE & STEER</div>
            <div class="touch-feedback-base" id="joy-visual">
                <div class="touch-feedback-knob" id="joy-knob"></div>
            </div>
        </div>
        
        <!-- RIGHT: BRAKE/DRIFT -->
        <div id="brake-zone" class="control-zone">
            <div class="zone-hint hint-right">HOLD TO DRIFT</div>
            <div class="touch-feedback-base" id="brake-visual">
                <div class="touch-feedback-knob"></div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

        let scene, camera, renderer;
        let bikeGroup, terrainMesh;
        let speed = 0;
        let lateralVelocity = 0; 
        let lastTurnInput = 0;   
        
        let velocity = new THREE.Vector3();
        let verticalVelocity = 0; 
        let particles = [];
        let rings = []; 
        let frameCount = 0;
        let lastTime = 0;
        let assetsLoaded = 0;
        let assetsTotal = 2; 
        let obstacles = [];
        
        let progressMoto = 0;
        let progressTree = 0;

        // GAMEPLAY STATS
        let battery = 100;
        const BATTERY_DRAIN = 0.05; 
        const RING_CHARGE = 20;

        // --- NEW MAP & WIN LOGIC ---
        const TOTAL_RINGS = 500;
        const WIN_PCT = 0.90;
        const REQUIRED_RINGS = Math.floor(TOTAL_RINGS * WIN_PCT);
        let collectedCount = 0;
        let exitUnlocked = false;
        let exitBeacon = null;
        // Place exit far away
        const EXIT_POS = { x: 4500, z: 4500 }; 
        const MAP_SIZE = 10000; // Match terrain size

        let isMapOpen = false;
        const bigMapCanvas = document.getElementById('big-map-canvas');
        const bigMapCtx = bigMapCanvas.getContext('2d');

        const MAX_SPEED = 1.2;
        const ACCEL = 0.02;
        const FRICTION = 0.98;
        const BRAKE_FRICTION = 0.92; 
        const TURN_SPEED = 0.04;
        const GRAVITY = 0.04; 
        
        const keys = { w: false, a: false, s: false, d: false, space: false, brake: false };
        
        let activeCameraMode = 0; 
        let analogSteering = 0;
        let analogThrottle = 0; 

        // --- CONTROLS LOGIC ---
        const controls = {
            init: function() {
                // JOYSTICK (LEFT)
                const joyZone = document.getElementById('joystick-zone');
                const joyVisual = document.getElementById('joy-visual');
                const joyKnob = document.getElementById('joy-knob');
                
                let joyActive = false;
                let joyOrigin = {x:0, y:0};
                const maxDist = 50;

                joyZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    joyActive = true;
                    const rect = joyZone.getBoundingClientRect();
                    joyOrigin.x = touch.clientX - rect.left;
                    joyOrigin.y = touch.clientY - rect.top;
                    
                    joyVisual.style.display = 'block';
                    joyVisual.style.left = joyOrigin.x + 'px';
                    joyVisual.style.top = joyOrigin.y + 'px';
                    joyKnob.style.transform = `translate(-50%, -50%)`;
                    sfx.init(); sfx.playMusic();
                }, { passive: false });

                joyZone.addEventListener('touchmove', (e) => {
                    if (!joyActive) return;
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    const rect = joyZone.getBoundingClientRect();
                    
                    let dx = (touch.clientX - rect.left) - joyOrigin.x;
                    let dy = (touch.clientY - rect.top) - joyOrigin.y;
                    
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    if (dist > maxDist) {
                        const angle = Math.atan2(dy, dx);
                        dx = Math.cos(angle) * maxDist;
                        dy = Math.sin(angle) * maxDist;
                    }

                    joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                    analogSteering = -(dx / maxDist);
                    analogThrottle = -(dy / maxDist);
                }, { passive: false });

                const endJoy = () => {
                    joyActive = false;
                    joyVisual.style.display = 'none';
                    analogSteering = 0;
                    analogThrottle = 0;
                };
                joyZone.addEventListener('touchend', endJoy);
                joyZone.addEventListener('touchcancel', endJoy);

                // DYNAMIC BRAKE (RIGHT)
                const brakeZone = document.getElementById('brake-zone');
                const brakeVisual = document.getElementById('brake-visual');

                brakeZone.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.changedTouches[0];
                    keys.brake = true;
                    sfx.init(); sfx.playMusic();
                    if(window.navigator.vibrate) window.navigator.vibrate(10);

                    const rect = brakeZone.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    
                    brakeVisual.style.display = 'block';
                    brakeVisual.style.left = x + 'px';
                    brakeVisual.style.top = y + 'px';
                }, { passive: false });

                const endBrake = (e) => {
                    e.preventDefault();
                    keys.brake = false;
                    brakeVisual.style.display = 'none';
                };
                brakeZone.addEventListener('touchend', endBrake);
                brakeZone.addEventListener('touchcancel', endBrake);
            }
        };

        const sfx = {
            ctx: null, engineOsc: null, engineGain: null, filter: null, noiseBuffer: null, skidOsc: null, skidGain: null, skidFilter: null,
            bgm: null, isMusicOn: true, isSfxOn: true,
            
            init: function() {
                if (this.ctx) {
                    if (this.ctx.state === 'suspended') this.ctx.resume();
                    return;
                }
                const AC = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AC();
                const bufferSize = this.ctx.sampleRate * 2; 
                this.noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = this.noiseBuffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                this.engineOsc = this.ctx.createOscillator(); this.engineOsc.type = 'sawtooth'; this.engineOsc.frequency.value = 40;
                this.engineGain = this.ctx.createGain(); this.engineGain.gain.value = 0;
                this.filter = this.ctx.createBiquadFilter(); this.filter.type = 'lowpass'; this.filter.frequency.value = 150;
                this.engineOsc.connect(this.filter); this.filter.connect(this.engineGain); this.engineGain.connect(this.ctx.destination);
                this.engineOsc.start();

                // --- MODIFIED SKID AUDIO CHAIN ---
                this.skidOsc = this.ctx.createOscillator();
                this.skidOsc.type = 'sawtooth'; 
                this.skidOsc.frequency.value = 35; 
                
                this.skidFilter = this.ctx.createBiquadFilter();
                this.skidFilter.type = 'lowpass';
                this.skidFilter.frequency.value = 250; 
                
                this.skidGain = this.ctx.createGain();
                this.skidGain.gain.value = 0;
                
                this.skidOsc.connect(this.skidFilter);
                this.skidFilter.connect(this.skidGain);
                this.skidGain.connect(this.ctx.destination);
                
                this.skidOsc.start();

                const playlist = [
                    "Cybertruking.mp3",
                    "cybertruck.mp3",
                    "Cybertruck - The Electric Juggernaut.mp3"
                ];

                const randomTrack = playlist[Math.floor(Math.random() * playlist.length)];
                console.log("Playing:", randomTrack);

                this.bgm = new Audio('music/' + randomTrack);
                this.bgm.loop = true;
                this.bgm.volume = 0.6;
                
                this.bgm.addEventListener('error', (e) => {
                    console.warn("Music file not found: music/" + randomTrack);
                });
            },
            
            playMusic: function() {
                if (this.bgm && this.isMusicOn && this.bgm.paused) {
                    this.bgm.play().catch(e => {
                    });
                }
            },

            toggleMusic: function() {
                this.isMusicOn = !this.isMusicOn;
                const btn = document.getElementById('music-indicator');
                if (this.isMusicOn) {
                    if(this.bgm) this.bgm.play().catch(e=>{});
                    btn.innerText = "MUSIC: ON";
                    btn.classList.remove('off');
                } else {
                    if(this.bgm) this.bgm.pause();
                    btn.innerText = "MUSIC: OFF";
                    btn.classList.add('off');
                }
            },

            toggleSfx: function() {
                this.isSfxOn = !this.isSfxOn;
                const btn = document.getElementById('sfx-indicator');
                if(this.isSfxOn) {
                    btn.innerText = "SFX: ON";
                    btn.classList.remove('off');
                } else {
                    btn.innerText = "SFX: OFF";
                    btn.classList.add('off');
                    if(this.engineGain) this.engineGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                    if(this.skidGain) this.skidGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                }
            },

            updateEngine: function(speedPercent, isSkidding) {
                if (!this.ctx || !this.isSfxOn) return;

                this.engineOsc.frequency.setTargetAtTime(40 + (speedPercent * 110), this.ctx.currentTime, 0.1);
                const vol = (0.05 + (speedPercent * 0.1)) * 0.3; 
                this.engineGain.gain.setTargetAtTime(vol, this.ctx.currentTime, 0.1);
                this.filter.frequency.setTargetAtTime(100 + (speedPercent * 600), this.ctx.currentTime, 0.1);

                if(isSkidding) {
                    this.skidGain.gain.setTargetAtTime(0.25, this.ctx.currentTime, 0.1); 
                    this.skidOsc.frequency.setTargetAtTime(35 + Math.random()*25, this.ctx.currentTime, 0.05); 
                    this.skidFilter.frequency.setTargetAtTime(200 + (speedPercent * 150), this.ctx.currentTime, 0.1);
                } else {
                    this.skidGain.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
                }
            },
            
            playLand: function(intensity) {
                if (!this.ctx || !this.isSfxOn) return;
                const src = this.ctx.createBufferSource(); src.buffer = this.noiseBuffer;
                const gain = this.ctx.createGain(); gain.gain.setValueAtTime(Math.min(intensity * 0.5, 0.5), this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                const filter = this.ctx.createBiquadFilter(); filter.type = 'lowpass';
                filter.frequency.setValueAtTime(300, this.ctx.currentTime); filter.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
                src.connect(filter); filter.connect(gain); gain.connect(this.ctx.destination);
                src.start(); src.stop(this.ctx.currentTime + 0.3);
            },
            playCollect: function() {
                if (!this.ctx || !this.isSfxOn) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = 'square';
                osc.frequency.setValueAtTime(220, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(440, this.ctx.currentTime + 0.1);
                // Reduced volume to 40% (0.12)
                gain.gain.setValueAtTime(0.12, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                osc.connect(gain); gain.connect(this.ctx.destination);
                osc.start(); osc.stop(this.ctx.currentTime + 0.5);
            }
        };

        function init() {
            const container = document.getElementById('canvas-container');
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB); scene.fog = new THREE.Fog(0xdcb183, 20, 200); 
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, highp: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
            renderer.shadowMap.enabled = true; renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping; renderer.toneMappingExposure = 1.1;
            container.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(50, 100, 50); dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096; dirLight.shadow.mapSize.height = 4096; dirLight.shadow.bias = -0.0001;
            scene.add(dirLight);

            createTerrain();
            createRings(); 
            createExitBeacon(); // Add hidden exit
            loadModels();

            window.addEventListener('resize', onWindowResize);
            // Spacebar map added
            document.addEventListener('keydown', (e) => { onKey(e, true); sfx.init(); sfx.playMusic(); });
            document.addEventListener('keyup', (e) => onKey(e, false));
            
            const camInd = document.getElementById('camera-indicator'); 
            camInd.addEventListener('click', (e) => { e.stopPropagation(); switchCamera(); });
            
            const musInd = document.getElementById('music-indicator');
            musInd.addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleMusic(); });

            const sfxInd = document.getElementById('sfx-indicator');
            sfxInd.addEventListener('click', (e) => { e.stopPropagation(); sfx.toggleSfx(); });

            const mapBtn = document.getElementById('map-toggle-btn');
            mapBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(); });

            const closeMapBtn = document.getElementById('close-map-btn');
            closeMapBtn.addEventListener('click', (e) => { e.stopPropagation(); toggleMap(); });

            controls.init(); 
            animate();
        }

        function toggleMap() {
            isMapOpen = !isMapOpen;
            const overlay = document.getElementById('map-overlay');
            if (isMapOpen) {
                overlay.style.display = 'flex';
                drawBigMap();
            } else {
                overlay.style.display = 'none';
            }
        }

        function updateProgress() {
            const total = Math.round((progressMoto + progressTree) / 2);
            const bar = document.getElementById('progress-bar');
            const text = document.getElementById('loading-text');
            if(bar) bar.style.width = total + "%";
            if(text && text.className !== 'error-msg') text.innerText = "DOWNLOADING... " + total + "%";
        }

        function reportError(name) {
             const text = document.getElementById('loading-text');
             if(text) { text.innerText = "ERROR: " + name + " NOT FOUND. USING FALLBACK."; text.className = "error-msg"; }
        }

        // --- MATH OPTIMIZED HEIGHT FUNCTION (NO RAYCASTER) ---
        // Returns the exact Y height of the terrain at x, z
        function calculateTerrainHeight(x, z) {
            // Must match the createTerrain formula exactly
            const y = (Math.sin(x * 0.03) * 5) + 
                      (Math.cos(z * 0.03) * 5) + 
                      (Math.sin(x * 0.1 + z * 0.1) * 1.5);
            
            const dist = Math.sqrt(x*x + z*z); 
            let bowl = 0; 
            if(dist > 100) bowl = (dist - 100) * 0.15;
            
            return y + bowl;
        }

        function getTerrainHeight(x, z) {
            // Replaces the slow raycaster with fast math
            return calculateTerrainHeight(x, z);
        }

        function createExitBeacon() {
            const geo = new THREE.CylinderGeometry(0, 1, 100, 8);
            geo.translate(0, 50, 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });
            exitBeacon = new THREE.Mesh(geo, mat);
            const y = getTerrainHeight(EXIT_POS.x, EXIT_POS.z);
            exitBeacon.position.set(EXIT_POS.x, y, EXIT_POS.z);
            exitBeacon.visible = false;
            scene.add(exitBeacon);
        }

        function createRings() {
            // MODIFIED: BIGGER RINGS (3.5 radius, 0.5 thick)
            const geo = new THREE.TorusGeometry(3.5, 0.5, 16, 32);
            const mat = new THREE.MeshStandardMaterial({ 
                color: 0xFFFF00, metalness: 0.1, roughness: 0.2, emissive: 0xFFFF00, emissiveIntensity: 0.8
            });

            // MODIFIED: Zoning for easier start
            // 30% of rings spawn closer to center
            const EASY_ZONE_COUNT = Math.floor(TOTAL_RINGS * 0.3);
            const EASY_RANGE = 2000;
            const FULL_RANGE = 9500;

            for(let i=0; i<TOTAL_RINGS; i++) {
                // Intelligent placement loop
                let valid = false;
                let x, z, y;
                let attempts = 0;
                
                // Select range
                const range = (i < EASY_ZONE_COUNT) ? EASY_RANGE : FULL_RANGE;

                while(!valid && attempts < 5) {
                    x = (Math.random() - 0.5) * range;
                    z = (Math.random() - 0.5) * range;
                    
                    // Check against rocks (simple distance check)
                    let collision = false;
                    for(let obs of obstacles) {
                        const dx = x - obs.x;
                        const dz = z - obs.z;
                        if(dx*dx + dz*dz < (obs.radius + 2)*(obs.radius + 2)) {
                            collision = true;
                            break;
                        }
                    }
                    if(!collision) valid = true;
                    attempts++;
                }

                y = getTerrainHeight(x, z);
                const ring = new THREE.Mesh(geo, mat);
                // MODIFIED: Float higher (+3.5)
                ring.position.set(x, y + 3.5, z); 
                ring.rotation.y = Math.random() * Math.PI;
                ring.castShadow = true;
                scene.add(ring);
                rings.push(ring);
            }
        }

        function loadModels() {
            const loader = new FBXLoader();
            bikeGroup = new THREE.Group(); scene.add(bikeGroup); 

            // 1. Load Moto
            loader.load('fbx/moto.fbx', (object) => {
                object.scale.set(0.005, 0.005, 0.005);
                object.rotation.y = 0; 
                object.traverse((child) => { if (child.isMesh) { child.castShadow = true; child.receiveShadow = true; } });
                bikeGroup.add(object);
                addExhaust();
                assetsLoaded++;
                checkLoading();
            }, (xhr) => { if (xhr.lengthComputable) { progressMoto = (xhr.loaded / xhr.total) * 100; updateProgress(); } else { progressMoto = 50; updateProgress(); }
            }, (error) => { console.warn("Moto FBX missing."); reportError("moto.fbx"); createFallbackBike(); assetsLoaded++; checkLoading(); });

            // 2. High Res Procedural Trees (MATH OPTIMIZED)
            createHighResTrees();

            createRocks();
        }

        function createHighResTrees() {
            const count = 15000; // 15k trees
            const dummy = new THREE.Object3D();
            
            const trunkGeo = new THREE.CylinderGeometry(0.3, 0.5, 2.5, 8); 
            trunkGeo.translate(0, 1.25, 0); 
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x5C4033, roughness: 0.9 });
            const trunkMesh = new THREE.InstancedMesh(trunkGeo, trunkMat, count);

            const c1 = new THREE.ConeGeometry(2.0, 2.5, 8); c1.translate(0, 3.0, 0);
            const c2 = new THREE.ConeGeometry(1.6, 2.2, 8); c2.translate(0, 4.2, 0);
            const c3 = new THREE.ConeGeometry(1.0, 1.8, 8); c3.translate(0, 5.2, 0);
            
            const leafGeo = BufferGeometryUtils.mergeGeometries([c1, c2, c3]);
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x228B22, roughness: 0.8, flatShading: false });
            const leafMesh = new THREE.InstancedMesh(leafGeo, leafMat, count);

            trunkMesh.castShadow = true; trunkMesh.receiveShadow = true; trunkMesh.frustumCulled = false;
            leafMesh.castShadow = true; leafMesh.receiveShadow = true; leafMesh.frustumCulled = false;

            for(let i=0; i<count; i++) {
                const x = (Math.random() - 0.5) * 9500; 
                const z = (Math.random() - 0.5) * 9500;
                
                if(Math.abs(x) < 25 && Math.abs(z) < 25) { 
                    dummy.position.set(0, -100, 0); 
                    dummy.updateMatrix();
                    trunkMesh.setMatrixAt(i, dummy.matrix);
                    leafMesh.setMatrixAt(i, dummy.matrix);
                    continue; 
                }

                // OPTIMIZATION: Use pure math instead of raycaster
                const y = calculateTerrainHeight(x, z);
                
                const scale = 0.8 + Math.random() * 0.8; 
                
                dummy.position.set(x, y, z);
                dummy.rotation.set(0, Math.random() * Math.PI * 2, 0);
                dummy.scale.set(scale, scale, scale);
                dummy.updateMatrix();

                trunkMesh.setMatrixAt(i, dummy.matrix);
                leafMesh.setMatrixAt(i, dummy.matrix);
                
                obstacles.push({ x: x, z: z, radius: 1.5 * scale });
            }
            
            scene.add(trunkMesh);
            scene.add(leafMesh);
            
            assetsLoaded++;
            checkLoading();
        }
        
        function createFallbackBike() {
            const geo = new THREE.BoxGeometry(0.5, 0.5, 1); const mat = new THREE.MeshStandardMaterial({color: 0xff0000}); const mesh = new THREE.Mesh(geo, mat); mesh.position.y = 0.5; bikeGroup.add(mesh); addExhaust();
        }
        
        function addExhaust() { const exhaustPoint = new THREE.Object3D(); exhaustPoint.position.set(0, 0.5, -1.2); exhaustPoint.name = "exhaust"; bikeGroup.add(exhaustPoint); }
        function checkLoading() { 
            if (assetsLoaded >= assetsTotal) { 
                sfx.init(); sfx.playMusic();
                setTimeout(() => { document.getElementById('loading').style.display = 'none'; }, 500); 
            } 
        }
        
        function setupTouchControls() {
            joystick.init();
            const bindBtn = (id, key) => {
                const btn = document.getElementById(id);
                const start = (e) => { e.preventDefault(); keys[key] = true; btn.classList.add('active'); sfx.init(); sfx.playMusic(); if(window.navigator.vibrate) window.navigator.vibrate(10); };
                const end = (e) => { e.preventDefault(); keys[key] = false; btn.classList.remove('active'); };
                btn.addEventListener('touchstart', start, { passive: false }); btn.addEventListener('touchend', end, { passive: false });
            };
        }

        function createTerrain() {
            // 500x500 segments = 250,000 vertices (Fast to render, slow to raycast)
            const geometry = new THREE.PlaneGeometry(10000, 10000, 500, 500); 
            geometry.rotateX(-Math.PI / 2); 
            const positions = geometry.attributes.position.array;
            
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i]; 
                const z = positions[i + 2];
                // Use the exact same formula, NO RANDOMNESS for deterministic match
                positions[i + 1] = calculateTerrainHeight(x, z);
            }
            
            geometry.computeVertexNormals();
            const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 1024; const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#3E2712'; ctx.fillRect(0,0,1024,1024);
            for(let i=0; i<50000; i++) {
                const shade = Math.random(); if(shade > 0.6) ctx.fillStyle = '#4A3218'; else if (shade > 0.3) ctx.fillStyle = '#2E1F16'; else ctx.fillStyle = '#2F3A15';
                const x = Math.random() * 1024; const y = Math.random() * 1024; const size = Math.random() * 3 + 1; ctx.fillRect(x, y, size, size);
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping; 
            tex.repeat.set(100, 100);
            const material = new THREE.MeshStandardMaterial({ map: tex, roughness: 0.9 });
            terrainMesh = new THREE.Mesh(geometry, material); terrainMesh.receiveShadow = true; scene.add(terrainMesh);
        }

        function createRocks() {
             const rockGeo = new THREE.DodecahedronGeometry(1, 0); const rockMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });
            for(let i=0; i< 200; i++) { 
                const x = (Math.random() - 0.5) * 9000; 
                const z = (Math.random() - 0.5) * 9000; 
                const y = getTerrainHeight(x, z); 
                const rock = new THREE.Mesh(rockGeo, rockMat); 
                rock.position.set(x, y + 0.5, z); 
                rock.scale.set(1 + Math.random(), 1 + Math.random(), 1 + Math.random()); 
                rock.rotation.set(Math.random(), Math.random(), Math.random()); 
                rock.castShadow = true; 
                scene.add(rock); 
                obstacles.push({ x: x, z: z, radius: 1.0 }); 
            }
        }
        
        function createDriftSmoke(intensity) {
            if(!bikeGroup) return; 
            const offset = new THREE.Vector3(0, 0.2, 0.5); 
            offset.applyMatrix4(bikeGroup.matrixWorld);
            
            const geo = new THREE.DodecahedronGeometry(0.3 * Math.min(intensity * 3, 2.0), 0);
            const mat = new THREE.MeshBasicMaterial({ color: 0xdddddd, transparent: true, opacity: 0.6 });
            const p = new THREE.Mesh(geo, mat);
            
            p.position.copy(offset);
            p.position.x += (Math.random() - 0.5) * 0.5;
            p.position.z += (Math.random() - 0.5) * 0.5;
            
            const gH = getTerrainHeight(p.position.x, p.position.z);
            if(p.position.y < gH) p.position.y = gH + 0.1;
            
            scene.add(p);
            particles.push({ mesh: p, life: 1.5 + intensity, isSmoke: true });
        }

        function createDust() {
            if(!bikeGroup) return; const exhaust = bikeGroup.getObjectByName("exhaust"); if (!exhaust) return; if (Math.abs(speed) < 0.1) return;
            const pos = new THREE.Vector3(); exhaust.getWorldPosition(pos); const geo = new THREE.BoxGeometry(0.2, 0.2, 0.2); const mat = new THREE.MeshBasicMaterial({ color: 0x8b7e66, transparent: true, opacity: 0.4 }); const p = new THREE.Mesh(geo, mat); p.position.copy(pos); p.position.x += (Math.random() - 0.5) * 0.3; const gH = getTerrainHeight(pos.x, pos.z); if(p.position.y < gH) p.position.y = gH + 0.2; scene.add(p); particles.push({ mesh: p, life: 1.0 });
        }
        function updateParticles() { 
            for (let i = particles.length - 1; i >= 0; i--) { 
                const p = particles[i]; 
                p.life -= 0.02; 
                p.mesh.position.y += 0.03; 
                
                if (p.isSmoke) {
                    p.mesh.scale.multiplyScalar(1.03); 
                    p.mesh.material.opacity = p.life * 0.5;
                } else {
                    p.mesh.position.y += 0.02; 
                    p.mesh.scale.multiplyScalar(1.05); 
                    p.mesh.material.opacity = p.life * 0.4; 
                    p.mesh.rotation.x += 0.1; 
                }
                
                if (p.life <= 0) { 
                    scene.remove(p.mesh); 
                    particles.splice(i, 1); 
                } 
            } 
        }
        function onKey(e, pressed) { 
            const k = e.key.toLowerCase(); 
            if (k === 'w' || k === 'arrowup') keys.w = pressed; 
            if (k === 's' || k === 'arrowdown') keys.s = pressed; 
            if (k === 'a' || k === 'arrowleft') keys.a = pressed; 
            if (k === 'd' || k === 'arrowright') keys.d = pressed; 
            if (k === ' ') keys.brake = pressed; 
        }
        
        function switchCamera() { 
            activeCameraMode = (activeCameraMode + 1) % 2; 
            const ind = document.getElementById('camera-indicator'); 
            let nextMode = (activeCameraMode + 1) % 2;
            let label = "";
            switch(nextMode) {
                case 0: label = "CAM: ANGLED VIEW"; break;
                case 1: label = "CAM: TOP VIEW"; break;
            }
            ind.innerText = label;
        }
        
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function checkCollisions(newX, newZ) { const bikeRadius = 0.5; for(let obs of obstacles) { const dx = newX - obs.x; const dz = newZ - obs.z; const dist = Math.sqrt(dx*dx + dz*dz); if (dist < (bikeRadius + obs.radius)) return true; } return false; }

        function checkRings() {
            const playerPos = bikeGroup.position;
            let collectedInFrame = false;
            
            for(let i = rings.length - 1; i >= 0; i--) {
                const ring = rings[i];
                ring.rotation.y += 0.05; 
                const dx = playerPos.x - ring.position.x;
                const dy = (playerPos.y + 0.5) - ring.position.y; 
                const dz = playerPos.z - ring.position.z;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);

                // MODIFIED: INCREASED HITBOX TO 5.0 (easier to hit)
                if (dist < 5.0) {
                    scene.remove(ring); 
                    rings.splice(i, 1); 
                    collectedCount++;
                    collectedInFrame = true;
                    sfx.playCollect(); 
                    battery = Math.min(100, battery + RING_CHARGE);
                }
            }

            if(collectedInFrame) {
                // Update text
                document.getElementById('objective-text').innerText = `RINGS: ${collectedCount} / ${TOTAL_RINGS}`;
                // Check Win Condition
                if(collectedCount >= REQUIRED_RINGS && !exitUnlocked) {
                    exitUnlocked = true;
                    exitBeacon.visible = true;
                    document.getElementById('rings-status').innerText = "TARGET UNLOCKED: GO TO GREEN BEACON!";
                    document.getElementById('rings-status').classList.add('accent');
                    document.getElementById('compass-label').innerText = "TARGET";
                }
            }

            // Check Exit
            if(exitUnlocked) {
                const exDx = playerPos.x - EXIT_POS.x;
                const exDz = playerPos.z - EXIT_POS.z;
                if(Math.sqrt(exDx*exDx + exDz*exDz) < 10) {
                    document.getElementById('win-msg').style.display = 'block';
                    speed = 0;
                }
            }
        }

        function updateBattery() {
            if (Math.abs(speed) > 0.01) {
                battery -= BATTERY_DRAIN;
                if (battery < 0) battery = 0;
            }
            
            const bar = document.getElementById('battery-bar');
            const txt = document.getElementById('battery-text');
            bar.style.width = battery + "%";
            txt.innerText = "BATTERY: " + Math.round(battery) + "%";
            
            if (battery <= 0) {
                speed *= 0.95; 
            }
        }

        function drawBigMap() {
            if (!isMapOpen) return;
            // Draw once per frame when open
            bigMapCtx.clearRect(0, 0, 600, 600);
            const mapScale = 600 / MAP_SIZE;
            const centerOffset = 300; 

            // Draw Rings
            bigMapCtx.fillStyle = '#ffcc00';
            for(let ring of rings) {
                const rx = (ring.position.x * mapScale) + centerOffset;
                const ry = (ring.position.z * mapScale) + centerOffset;
                bigMapCtx.beginPath();
                bigMapCtx.arc(rx, ry, 3, 0, Math.PI*2); // Bigger dots
                bigMapCtx.fill();
            }

            // Draw Exit
            if(exitUnlocked) {
                bigMapCtx.fillStyle = '#00ff00';
                const exX = (EXIT_POS.x * mapScale) + centerOffset;
                const exY = (EXIT_POS.z * mapScale) + centerOffset;
                bigMapCtx.beginPath();
                bigMapCtx.arc(exX, exY, 10, 0, Math.PI*2);
                bigMapCtx.fill();
                bigMapCtx.fillStyle = '#00ff00';
                bigMapCtx.font = "14px monospace";
                bigMapCtx.fillText("EXIT", exX + 15, exY + 5);
            }

            // Draw Player
            if(bikeGroup) {
                bigMapCtx.fillStyle = '#ffffff';
                const px = (bikeGroup.position.x * mapScale) + centerOffset;
                const py = (bikeGroup.position.z * mapScale) + centerOffset;
                
                bigMapCtx.save();
                bigMapCtx.translate(px, py);
                bigMapCtx.rotate(-bikeGroup.rotation.y); 
                bigMapCtx.beginPath();
                bigMapCtx.moveTo(0, -10);
                bigMapCtx.lineTo(8, 8);
                bigMapCtx.lineTo(-8, 8);
                bigMapCtx.closePath();
                bigMapCtx.fill();
                bigMapCtx.restore();
            }
            requestAnimationFrame(drawBigMap);
        }

        function updateCompass() {
            if (!bikeGroup) return;
            const playerPos = bikeGroup.position;
            const playerRot = bikeGroup.rotation.y;
            let target = null;

            if (exitUnlocked) {
                target = new THREE.Vector3(EXIT_POS.x, 0, EXIT_POS.z);
            } else {
                // Find nearest ring
                let minDist = Infinity;
                for(let r of rings) {
                    const d = playerPos.distanceToSquared(r.position);
                    if(d < minDist) {
                        minDist = d;
                        target = r.position;
                    }
                }
            }

            if (target) {
                const dx = target.x - playerPos.x;
                const dz = target.z - playerPos.z;
                // Angle to target in world space (rads)
                // Math.atan2(z, x) usually, but check 3JS coordinate system.
                // In 3JS: Z is forward/back, X is left/right. 
                // atan2(dx, dz) gives angle from North (Z) clockwise? No.
                // Standard trig: atan2(y, x). Here: atan2(x, z).
                const targetAngle = Math.atan2(dx, dz);
                
                // Relative angle = Target - Player
                // However, player rotation Y is usually counter-clockwise from Z? 
                // Let's adjust until it looks right.
                // Compass Arrow Rotation needs to act like a real compass relative to screen (fixed) or car (rotating)?
                // "Compass style directional indicator" usually means arrow points relative to car's forward.
                
                const relativeAngle = targetAngle - playerRot;
                const deg = THREE.MathUtils.radToDeg(relativeAngle);
                
                document.getElementById('compass-arrow').style.transform = `rotate(${deg}deg)`;
            }
        }

        function animate(time) {
            requestAnimationFrame(animate);
            if (time - lastTime >= 1000) { document.getElementById('fps').innerText = frameCount + " FPS"; frameCount = 0; lastTime = time; }
            frameCount++;

            let throttleInput = 0;
            if (keys.w) throttleInput += 1;
            if (keys.s) throttleInput -= 1;
            if (Math.abs(analogThrottle) > 0.1) throttleInput += analogThrottle;

            if (battery > 0) { if (throttleInput > 0) speed += ACCEL * throttleInput; }
            if (throttleInput < 0) speed += ACCEL * throttleInput; 
            
            let turnInput = 0; if (keys.a) turnInput += 1; if (keys.d) turnInput -= 1; turnInput += analogSteering; 

            // --- ADVANCED MOTO DRIFT PHYSICS 4.0 (REALISM UPDATE) ---
            
            const turnDelta = turnInput - lastTurnInput;
            lastTurnInput = turnInput;

            let isDrifting = false;

            const MIN_DRIFT_SPEED = 0.25;
            const GRIP_FRICTION = 0.90;  
            const DRIFT_FRICTION = 0.92; 

            if (keys.brake && Math.abs(speed) > MIN_DRIFT_SPEED && Math.abs(turnInput) > 0.1) {
                isDrifting = true;
                
                const breakoutForce = (speed * speed) * turnInput * 0.025;
                lateralVelocity += breakoutForce;

                bikeGroup.rotation.y += turnInput * 0.06;
                
                speed *= 0.96; 

            } else {
                isDrifting = false;
                
                if(keys.brake) speed *= BRAKE_FRICTION;
                
                lateralVelocity *= GRIP_FRICTION;
                
                if (Math.abs(speed) > 0.05) {
                    const speedFactor = 1.0 - (Math.abs(speed) * 0.3);
                    bikeGroup.rotation.y += turnInput * TURN_SPEED * speedFactor;
                }
            }
            
            if(!keys.brake) speed *= FRICTION;

            if (isDrifting) lateralVelocity *= DRIFT_FRICTION;

            if (bikeGroup) {
                const forwardVec = new THREE.Vector3(0, 0, speed);
                const sideVec = new THREE.Vector3(lateralVelocity, 0, 0);
                
                const totalVec = new THREE.Vector3().addVectors(forwardVec, sideVec);
                totalVec.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                
                const nextX = bikeGroup.position.x + totalVec.x; 
                const nextZ = bikeGroup.position.z + totalVec.z;

                if (Math.abs(lateralVelocity) > 0.05 && frameCount % 3 === 0) {
                    createDriftSmoke(Math.abs(lateralVelocity));
                }

                if (checkCollisions(nextX, nextZ)) { 
                    speed = -speed * 0.5; sfx.playLand(1.0); 
                } else { 
                    bikeGroup.position.add(totalVec);
                }

                sfx.updateEngine(Math.abs(speed), isDrifting);
                checkRings();
                updateBattery();
                updateCompass(); // UPDATE COMPASS

                // Terrain Following
                // Use fast math here too
                const groundH = getTerrainHeight(bikeGroup.position.x, bikeGroup.position.z);
                verticalVelocity -= GRAVITY; 
                bikeGroup.position.y += verticalVelocity;

                if (bikeGroup.position.y < groundH) { 
                    bikeGroup.position.y = groundH; 
                    verticalVelocity = 0; 
                }

                const aheadV = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                const nextH = getTerrainHeight(bikeGroup.position.x + aheadV.x, bikeGroup.position.z + aheadV.z);
                const angle = Math.atan2(nextH - groundH, 1.0); 
                bikeGroup.rotation.x = THREE.MathUtils.lerp(bikeGroup.rotation.x, -angle, 0.2);
                
                let targetLean = -turnInput * 0.6 * (Math.abs(speed) / MAX_SPEED);
                
                if (isDrifting) {
                    targetLean *= 1.2; 
                    targetLean += Math.sin(time * 0.015) * 0.05;
                }
                
                bikeGroup.rotation.z = THREE.MathUtils.lerp(bikeGroup.rotation.z, targetLean, 0.1);

                const targetPos = bikeGroup.position.clone();
                let camOffset = new THREE.Vector3();
                let lookOffset = new THREE.Vector3(0, 1, 0);

                switch(activeCameraMode) {
                    case 0: // Chase Standard
                        camOffset.set(0, 4, -8);
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                        if (isDrifting) {
                            camOffset.x -= lateralVelocity * 5.0; 
                        }
                        break;
                    case 1: // Top Down
                        camOffset.set(0, 25, -2);
                        camOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), bikeGroup.rotation.y);
                        break;
                }

                const camPos = targetPos.clone().add(camOffset);
                const camGroundH = getTerrainHeight(camPos.x, camPos.z);
                if (camPos.y < camGroundH + 1.0) camPos.y = camGroundH + 1.0;

                camera.position.lerp(camPos, 0.1);
                camera.lookAt(targetPos.clone().add(lookOffset));
            }

            createDust(); updateParticles();
            document.getElementById('speed').innerText = Math.abs(Math.round(speed * 100)) + " KM/H";
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>